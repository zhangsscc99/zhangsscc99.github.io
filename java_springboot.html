<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>以雷霆击碎SpringBoot</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin-top: 50px;
        }
        .main-title {
            color: #007BFF;
            font-size: 2em;
        }
        .description {
            margin-top: 20px;
            font-size: 1.2em;
        }
        .tips {
            margin-top: 40px;
            color: #28a745;
            font-size: 1em;
        }
    </style>
</head>
<body>
    <div class="content">
        <div class="link-to-other-page">
            <a href="index.html">首页/返回</a>
        </div>
        <h1 class="main-title">以雷霆击碎SpringBoot</h1>
        <p class="description">面对编程挑战，我们如同雷霆，击破一切难题。</p>
        <p class="tips">开始你的编程之旅，你的道路没有岔口，因为未来，早已笃定。</p>
        <div class="link-to-other-page">
            <p style="white-space: pre-line;">
                好课推荐
                https://www.bilibili.com/video/BV1gc41117ta?p=3&spm_id_from=pageDriver&vd_source=d4b859b0532ebb11fd37c3b6f643100f
                1. protected, private, public, default这样的access modifier都解释一遍 并且用例子说明

                对于public修饰符，它具有最大的访问权限，可以访问任何一个在CLASSPATH下的类、接口、异常等。它往往用于对外的情况，也就是对象或类对外的一种接口的形式。
                这个权限比较高
                protected的权限排第二 不可以被外部包访问，但是子类啥的都行，包括本包和类内部。
                主要作用就是保护子类。
                相当于protected就是传递给子类的
                default的话，一般子类也不可以。只能本包和类的内部。
                而private最严格，本包都不行 只能类的内部可以。
                
                2. 
                @AuthenticationPrincipal User user：
这个注解自动地将当前经过认证的用户注入方法中。在Spring Security环境下，它通常用来获取代表当前用户的User对象。User是Spring Security提供的一个用户详情类，它包含了当前用户的信息，比如用户名、密码和授权
            3. JPA Repository
            JPA Repository refers to a set of interfaces in Spring Data JPA that abstracts away the boilerplate code required to perform CRUD (Create, Read, Update, Delete) operations on entities. When you extend interfaces like JpaRepository, Spring Data JPA automatically provides implementations for methods like save(), findAll(), findById(), deleteById(), etc.
            
            For example, JpaRepository is a JPA-specific extension of the Repository interface that comes with additional JPA-related methods. It provides a way to perform various operations on the entity, including finding, saving, and deleting records without needing to write any implementation code.
            
            These annotations and interfaces significantly reduce the amount of boilerplate code developers 
            @Entity
The @Entity annotation marks a class as a JPA entity. An entity represents a table stored in a database. Every instance of an entity corresponds to a row in the table. This annotation tells the JPA provider that the class should be mapped to a database table.

@Id
The @Id annotation marks a field as the primary key of the entity. The primary key uniquely identifies each entry in the database table. This annotation is placed on the field that maps to the primary key column of the table.

@GeneratedValue
The @GeneratedValue annotation is used in conjunction with @Id to specify the primary key generation strategy for the entity. It indicates that the persistence provider should automatically generate the primary key for the entities. The strategy attribute of @GeneratedValue allows you to select the primary key generation strategy, such as AUTO, SEQUENCE, IDENTITY, or TABLE. AUTO is the default strategy and lets the persistence provider choose the strategy based on the database capabilities.
4.@RestController is a special type of @Controller that contains the semantics of @ResponseBody, which means that the returned object will be automatically serialized into JSON and written into the HTTP response body
5.Why do we need to constantly serialize and deserialize JSON? This process is critical to the functionality of the REST API for several reasons:

Data exchange format: JSON is a lightweight data exchange format that can easily transfer data between different systems. Due to its simplicity and ease of human readability, it has become the de facto standard for data exchange in Web APIs.

Language-independence: JSON is a language-independent data format that does not rely on the specific structure of any programming language. This means that no matter what language the server and client are written in, they can communicate via JSON.

Network transfer: Network transfer usually involves the exchange of data in text format. Serialization converts an object or data structure into a JSON string so that it can be sent over network protocols such as HTTP. In contrast, deserialization converts the received JSON string back into the original object or data structure for use within the program.

Data storage: JSON format is also often used to store data (such as in databases) because it is very readable and concise.

Security: The serialization and deserialization process can serve as a simple form of data validation. When deserializing, you can check whether the JSON data conforms to the expected format, thereby avoiding problems caused by incorrect or malicious data structures.
6. why repo?
high-level abstraction. for data access and manipulation. rather writing custom data access code(such as sql queries)
provide a generic api for accessing and manipulating entities. 


Purpose of UserRepository Interface
The UserRepository interface, as an example, is designed to manage the data access operations for User entities. By extending JpaRepository, it inherits a set of methods for performing CRUD (Create, Read, Update, Delete) operations, as well as pagination and sorting functionality. Developers can also define custom query methods in this interface, and Spring Data JPA will automatically provide the implementation based on the method name or the custom query annotation (@Query). This greatly reduces the amount of boilerplate code required to interact with the database.
7 spring, SpringBoot
springboot是spring生态的产品
spring framework是一个容器框架
springboot不是一个框架 快速构建基于spring的脚手架
为开发spring生态其他框架铺平道路
2个不是一个层面的东西 没有可比性
8  springboot的核心注解
java config的配置版本（xml的配置直接跳到springboot的配置方式）
springbootapplication 启动类这里
当前应用是springboot应用
springboot configuration也是一个原注解
启动类是一个配置类
enableautoconfiguration这个注解就是用来启动自动配置类的，扫面所有能使用的自动配置类
自动配置类概念：springboot里的
很多自动配置类里面：autoconfiguration。
conditionalOnProperty
springboot单独提供出来的
conditionalonclass onbean这些都是核心注解

The image you've uploaded appears to be a screenshot of some text explaining various annotations related to Spring Boot's conditional registration of beans. Specifically, the text seems to be describing @Conditional annotations which are a series of annotations that allow you to conditionally register beans in the Spring context based on certain criteria. Let's go over them in English:

@ConditionalOnBean: This annotation is used to conditionally include a bean into the Spring ApplicationContext only if a bean with the specified name is already present in the ApplicationContext.

@ConditionalOnClass: This one is used to register a bean only if the specified classes are present in the classpath. It ensures that the bean will not be created if the required class is not found, preventing class-related errors.

@ConditionalOnExpression: This allows for the inclusion of a bean based on the result of a SpEL (Spring Expression Language) expression. It gives you a powerful way to control bean registration dynamically, based on the evaluation of the expression.

These annotations are part of Spring Boot's auto-configuration magic, which tries to automatically configure your Spring application based on the jar dependencies that you have added. They can be particularly useful for creating auto-configuration classes that conditionally define beans to auto-configure a Spring application according to the presence or absence of certain criteria.
9springboot bean
Yes, you can understand a bean as an object that contains all the information an object would have, and it can indeed be used for passing data, among other functionalities. To make this clearer, let's use a metaphor involving a coffee shop to explain the concept of beans, objects, and their roles within the Spring Framework.

The Coffee Shop Metaphor
Imagine you walk into a coffee shop (the Spring Framework) to get a cup of coffee (an object). This coffee shop is unique because it has a special service (the Spring IoC container) that prepares your coffee for you exactly how you like it without you having to do it yourself.

Coffee Beans (Spring Beans): Just as coffee beans are the essential ingredient to make a cup of coffee, Spring beans are the essential components used by the Spring Framework to create objects. These beans are not simple Java objects; they are special because the Spring container manages them. This means that the container creates these objects, configures them with the right settings (like how you might like your coffee with a specific amount of sugar and milk), and manages their entire lifecycle.

The Recipe (Bean Configuration): Before the coffee shop can make your coffee, they need to know how you like it. This is similar to defining a bean in Spring. You can tell Spring how to create your object (bean), what ingredients (dependencies) it needs, and other settings through configurations. This can be done in various ways, such as XML files, annotations, or Java config classes, much like how you can order your coffee verbally, write it down on a piece of paper, or select options on a touchscreen.

Making the Coffee (Object Instantiation): When you order your coffee, the coffee shop's service (Spring IoC container) goes to work. It takes the coffee beans (Spring beans), follows the recipe (bean configuration), and makes your coffee (object). This process is managed entirely by the coffee shop, so you don't have to grind the beans, boil the water, or mix the ingredients yourself. Similarly, Spring takes care of creating objects and managing them according to the defined configurations, so developers don't have to write boilerplate code for object creation, lifecycle management, and dependency resolution.

Serving the Coffee (Dependency Injection): If your coffee requires milk, the coffee shop adds milk to it before serving. This is like Spring's dependency injection. If a bean needs another bean to work (like a coffee needs milk), Spring ensures that the required bean is created and "injected" into the bean that needs it.

Enjoying Your Coffee (Using the Bean/Object): Finally, you get your coffee exactly how you like it, ready to drink. In your application, the Spring-managed beans are ready to be used wherever needed, configured and assembled according to your specifications.
In this metaphor, the coffee shop takes the responsibility off your hands and ensures your coffee is made correctly, just as Spring manages your objects (beans) and their dependencies, freeing you to focus on the more important parts of your application's logic.

</p>
        </div>
    </div>
</body>
</html>
