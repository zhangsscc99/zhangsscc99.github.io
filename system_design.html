1设计用户系统
scenario 需求量最大的是
用户信息修改
查询


2 qps 
Authentication Service  
UserService  
1000 qps db mysql  
cassandra, mongodb, 10k qps

100k-1m qps redis, memcached 内存型nosql  
十万到百万

2-3万高并发 redis单机


3 300k的查询请求 读请求
可以用cache进行优化 读多写少 用cache
memcached不支持数据持久化
file system支持更慢的数据 很远的地方 先存在local。
计算量很大的工作的cache 算十分钟 算一次

10万高并发不一定等同于10万QPS（Queries Per Second，或Requests Per Second）。高并发指的是系统能够同时处理的用户请求数量，而QPS则是系统每秒钟处理的请求数量。

例如：

高并发场景：如果系统能够同时处理10万个并发连接（用户请求），这些请求可以是长时间保持的连接，如WebSocket连接、HTTP长连接等。

高QPS场景：如果系统每秒能够处理10万个请求，这些请求可以是短暂的HTTP请求，每个请求的处理时间很短，但每秒的请求量很大。

高并发和高QPS可以同时存在，也可以单独存在。例如，一个聊天应用可能需要高并发但不一定需要高QPS，因为用户连接数多但消息发送频率低；而一个搜索引擎可能需要高QPS但不一定需要高并发，因为用户搜索请求频繁但每个请求处理时间短。

因此，10万高并发和10万QPS的区别在于：

高并发：关注的是同时连接的数量，用户请求可以长时间存在。
高QPS：关注的是每秒处理的请求数量，用户请求处理时间通常很短。
要明确区分它们，需要根据具体的应用场景和需求来进行定义。


看到用户系统和内存缓存

4memcache如何优化db的查询
memoization
计划搜索
数据库和缓存不一致 脏数据
操作原子性 第一个失败 第二个成功 不用管
数据库和缓存不能都加锁

分布式锁 效率太低了 mutex

多进程是不行的 变量级别锁是不行的

zookeeper  

db到set cache到delete 业界最佳
cache里放旧数据
读多写少 很多要读 可能就load回来了


读多写少 先set一下user 再cache delete。
hit rate。cache hit rate 98%以上


脚本定时任务同步 是不现实的
cache ttl机制 timeout 缓解一致性问题
cache time to live 不是特别完美 但是最省力省时间。解决cache和db数据不一致。
为什么不是cache set 因为这样经常数据不一致

5 写多读少
没法使用cache优化
cache aside架构
db->web server -> cache
memcached + mySql


cache through 用的少 
服务器只和cache沟通
cache负责db沟通把数据持久化
redis包含了cache和db 可以理解为
cache aside的方式较多。

小厂写多就多来几台机器
redis缺点 单纯支持key value  范围查询不适用
大厂自己搭建cache through 小厂没有资本

authentication Service 
session对象。

假设你去了一家餐厅用餐。

Cookie 比喻：会员卡
会员卡记录信息：当你第一次来到餐厅时，餐厅给了你一张会员卡（cookie），这张卡上记录了你的会员信息（例如，你的名字、喜欢的菜品等）。
随身携带：每次你再次来到这家餐厅，你都需要出示这张会员卡。餐厅通过这张会员卡识别你是谁，并快速了解你的偏好。
存储在顾客手中：这张会员卡是由你自己保管的（存在浏览器中），每次你进餐时都需要出示。
长期有效：会员卡通常在一定时间内有效（直到 cookie 过期或被删除）。
Session 比喻：餐厅内部的账单
创建账单：当你走进餐厅坐下时，餐厅在内部创建了一张属于你的账单（session），这张账单记录了你在这次用餐中的所有点菜和消费情况。
账单编号：餐厅给你一个账单编号（session ID），你只需告诉服务员这个编号，他们就能找到你的账单并添加新的点菜记录。
存储在餐厅：这张账单是由餐厅保管的（存在服务器中），你只需要记住账单编号。
短期有效：账单在你这次用餐结束后（例如，你离开餐厅或支付账单后）通常就会失效。
结合使用：
首次访问：当你第一次来到餐厅时，餐厅给了你一张会员卡（cookie）和一个账单编号（session ID），这样他们既知道你的会员信息，又能记录你的当前消费。
再次访问：下次你再来时，出示会员卡（cookie），餐厅会根据会员卡找到你的会员信息。同时，他们会给你新的账单编号（session ID）记录本次消费。
现实应用：
Cookie：当你访问一个网站时，网站会在你的浏览器中存储一个 cookie，这个 cookie 记录了你的用户信息或偏好。下次访问时，浏览器会携带这个 cookie 让网站识别你。
Session：当你登录网站时，网站在服务器端创建一个 session 来记录你的登录状态和操作。服务器给你的浏览器发送一个 session ID，浏览器在后续请求中携带这个 session ID，服务器根据这个 ID 找到相应的 session 数据。
通过这个比喻，你可以更直观地理解 cookie 和 session 的概念以及它们在网络中的应用。


大概10分钟一节
10+10+17+5 