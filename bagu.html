1osi
物联网淑慧试用
物理层
数据链路层
网络层
传输层 
会话层 
表示层
应用层

2 五层 
物联网输用
物理层
数据链路层
网络层
传输层 
应用层 

tcp ip 
网络接口层 
网际层ip
运输层 
应用层

3 应用层 
进程间的交互 特定网络应用 
域名系统dns  
http  smtp协议 
数据单元 报文。 

4 进程之间的通信提供数据传输服务
tcp 面向连接 可靠的 数据传输服务 
udp 无连接 不保证数据传输的可靠性 
网络层 
多个数据链路 ip协议 ip数据报 
异构网络通过路由器连接起来 
无连接的网际协议。 
网际层 ip层。


ip数据报组装成帧 

物理层单位 比特 
屏蔽传输介质和物理设备的差异  
tcp ip协议族  


5 tcp三次握手 
发送带有syn标志的数据包 
服务端 
syn ack 客户端 
ack 服务端  

为什么三次握手
建立可靠的通信信道 
为什么传回syn 告诉发送端 我收到的就是你发送的信号 
握手信号 syn。可靠tcp连接。 
服务器用syn-ack应答。
接收方到发送方还需要ack信号验证。

断开需要四次挥手 
1 发送fin 关闭 
2 收到fin 发回ack  
3 关闭连接 发送fin给客户端 
4 发回ack。  


举个例⼦：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可
能还会有要说的话，A 不能要求 B 跟着⾃⼰的节奏结束通话，于是 B 可能⼜巴拉巴拉说了⼀通，最后
B 说“我说完了”，A 回答“知道了”，这样通话才算结束。

6
分割成tcp认为最适合发送的数据块 
保持首部和数据的检验和 
接收端丢弃重复数据  
流量控制 可变大小的滑动窗口协议 。
拥塞控制。 网络拥塞时 减少数据的发送。
arq  超时重传 tcp发出一个段后 启动一个定时器 。 不能及时确认 就重发。 


arq协议。 自动重传请求。  
确认和超时。 ack确认。 每发完一个分组就停止发送。 

7 拥塞控制 


8 https http与tcp之间增加了ssl tsl安全传输层 
把tcp换成了基于udp的quic 
服务器不记忆http状态 

9 cdn 内容分发网络 分布式服务器 
dns返回最近的cdn节点 负载和可用性 请求分发

10 cookie
set-cookie 

11 tcp流量控制
滑动窗口 
调整数据传输速率 
窗口大小 动态调整
缓冲区  动态调整 
ack报文。 

12 tcp拥塞控制 
慢启动 
拥塞避免。 
快速重传。 快速恢复。
sso是什么 登录认证机制。 登录信息写入session 生成cookie 返回写入浏览器。
根据cookie找session 判断登录与否 
单点登录 一次登录 访问多个应用。
sso优点 降低重用  
方便用户体验 
简化应用开发。
url 解析域名 dns  
ip地址。 浏览器向服务器发起tcp连接 tcp三次握手 
发送http请求 请求服务器端数据包。
处理请求 返回数据 
浏览器收到http相应。
状态成功下一步。
读取内容 浏览器渲染。 解析html源码。
处理js交互 解析css样式。
关闭tcp连接。


内容缓存。
压缩 
文本数据压缩 减少带宽。
ssl加速。
tcp缓冲。

先看缓存再进行dns查询。
发起dns查询。arp地址解析。
udp请求包。
分布式域名服务器。
https是443 http是80


3开头定向消息。四次挥手。
ssl加密技术 传输数据。
ajax技术。
浏览器缓存静态文件。

下发证书 包含公钥 
服务器随机数server random  


13 syn攻击 


14 cache control 强缓存
expires强缓存 内存中读取缓存并返回
实现 HTTP 缓存通常涉及使用 HTTP 标头来控制缓存行为。这些标头可以指导浏览器或代理服务器在本地缓存资源或从服务器重新获取资源。以下是一些常用的 HTTP 缓存标头及其用法示例：

1. Cache-Control
Cache-Control 标头用于指定缓存机制。它可以在服务器响应中设置，以控制资源在客户端和中间代理服务器中的缓存方式。

示例代码：

http
Copy code
HTTP/1.1 200 OK
Cache-Control: max-age=3600, must-revalidate


15 mongodb数据库 和sql区别
sql结构化查询 mongodb 自己的查询方式 
mongodb nosql。binary json 嵌套结构和数组 唯一的id字段作为主键。
无模式。动态添加字段 没有固定表结构。

非结构化 半结构化 
主从复制 垂直分区。横向扩展性比较好。
慢查询 2s以上。涉及多个表 查询数据量较大。缺少索引。
数据库设计不合理。
并发冲突。复杂连接和子查询。

explain 如何用索引 处理select语句。
选更好的索引。建立索引原则。


redis 高性能 高并发

是的，Redis 缓存通常是在处理 API 请求的过程中进行的，具体来说是在数据从数据库查询之后进行缓存的操作。然而，确实可以预先缓存数据，而不是在 API 请求时即时查询和缓存。这种方式被称为预缓存或预热缓存，通常用于一些频繁访问且变化不频繁的数据。

为什么要进行预缓存？
减少首次请求延迟：预缓存可以在应用程序启动或定时任务中提前加载数据到缓存中，减少用户首次访问时的等待时间。


redis单线程很快 内存存储 
不是磁盘。
非阻塞单线程。不需要上下文切换，非阻塞io。 
string list hash 高效数据结构。
提升读写效率。


16
静态文件 编译 代码 装载到内存 cpu执行每一条指令。
进程

17 连通图 任何两个节点都是可以到达的 连通图     
任何两个节点相互到达 有向图里 强连通图 
连通分量 极大连通子图里
子图所有节点可以相互达到。
有向图里 极大强连通子图 强连通分量  

有向无向会区分出强弱连通性。
连通子图就是连通分量。同样 有向无向区分出 强弱连通分量 
邻接矩阵 任意两个顶点 
稠密图  
grid[2][5] = 6 2连接5 的有向图 6是权值
相互连通 无向图 也要表示相互连通。
连通分量就是连通子图 任意两点互相连接 可以到达。
数组加链表就是邻接表 

18 拓扑排序 
有向图 转成线性排序 
拓扑排序 
判断有向无环图 
入度 0 出度2 
找入度0的节点 出发节点  
节点移除  
判断有向环 结果集元素个数 不等于图中节点个数  
找不到入度为0的节点了 
最小生成树 最小连通子图 所有节点的 
边的权值和最小  

选距离生成树最近节点  
最近节点加入生成树  
更新非生成树 节点到生成树的距离 更新minDist 数组  

一开始任选节点  
把有向图转向线性排序

19 
连通 p和p连通
对称性 p和q连通 那么q和p连通 
传递性 
p和q连通 q和r连通 那么p和r连通  
union(0, 1)
0和1被连通 连通分量降为9个 
union(1, 2)
0, 1, 2都被连通 
connected(0, 2) 也会返回true  
连通分量变为8个 

父节点指向自己  
count是连通分量  
就是极大连通子图  
强弱之分 有向无向  
跟节点相连
返回当前的连通分量个数 
返回某个节点x的根节点  
复杂度来看 极端不平衡就是N  
平衡二叉树 logN  
树退化成链表  
避免树的不平衡  
避免头重脚轻  size数组 记录节点数 
重量  
生长平衡 union要写好 那就是logN 
路径压缩  


生成树就是无环连通子图 

包含图中所有节点  
形成的结构是树结构 不存在环
权重和最小  
按权重大小排序  
和mst其它边不会形成环 最小生成树一部分 
加入mst集合。
连通城市的成本就是边的权重。
连通所有城市的最小成本就是最小生成树的权重之和。
要有按权重排序的逻辑。
树的判定加上权重排序就是kruskal算法。
优先级队列 小顶堆 对新链接的边排序

i j, k 为中间节点  
最短距离为m  

grid[i][j][k] = m  
经过很多节点  
什么方法表述这么多节点  
i到j经过或者不经过节点k  

找到右边第一个比自己大的元素 
存放元素下标  
求元素右边第一个更大元素  
单调要求严格单调递增或者严格单调递减  


拓扑排序：找入度为0的节点 移除 然后继续找入度为0的节点 

专家分享秘密的题目


差分数组o1就可以完成on


20 子集问题不需要not self.used[i - 1] 
排列问题需要的 因为 排列涉及顺序的

21排序
哨兵划分
递归
基准元素 小的放左边
大的放右边 
60放左边 80 90 放右边 


22 self.cache挺难的

哈希链表 插入删除快
并且查找也很快  


23 对于图论dijkstra来讲  
用邻接矩阵比较好 
visited记录访问过没有 
遍历节点 赋值minval  
找到最近节点 未访问过 设置为cur 
然后再次遍历 未访问过 存在路径 距离加起来更加小 minDist就会更新到别的v节点的距离 
最后返回minDist[end]  
如果-1 代表路径不存在 


24 动态规划  
背包问题 416 背包总容量 背包最大重量  
target就是sum的一半 记得整除 判断是否模2为0 

如果装满也正好等于一半 就是True 否则就是False了

25 求装满有几种方法
494 目标和 就是组合问题 那么就要使用的是 记忆化回溯或者先物品再背包  
先背包再物品就容易重复 

1 为什么这里494 不需要考虑先物品还是先背包？
这题是放物品数量 
物品内层排列
物品外层组合 

不强调集合是组合还是排列的话 就 物品内外都可以的

数组 链表  
0到25 
search  


std是命名空间
c::先找到命名空间 再使用cin 
std::cin  
输入运算符  
>> 
从输入流读取到变量。
std::cin >> a >> b;
多个值之间用空格隔开  
std::cout 
std::cout << res << std::endl;
输出结果 结束当前行 std::endl这个作用
正常每个结果占一行 单独  
iostream就有istream和ostream  
::是作用域操作符
std是命名空间  
C++标准库的内容  

