<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>图论专题</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        .main-title {
            color: #007BFF;
            font-size: 2em;
            text-align: center;
        }
        .content {
            margin-top: 20px;
        }
        .code-block {
            background-color: #f4f4f4;
            border-left: 3px solid #007BFF;
            padding: 10px;
            margin: 20px 0;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .link-to-other {
            display: block;
            margin-top: 20px;
            text-align: center;
            font-size: 1em;
            color: #28a745;
        }
    </style>
</head>
<body>
    <div class="content">
        <div class="link-to-other-page">
            <a href="index.html">首页/返回</a>
        </div>
        <h1 class="main-title">MapReduce</h1>
        <p></p>
        <div class="toc">
            <h2>Table of Contents</h2>
            <div class="toc-item"><a href="#section1">面试经验</a></div>
            <div class="toc-item"><a href="#section2">3月学习计划</a></div>
            <div class="toc-item"><a href="#section3">简历修改和公司调查</a></div>
            <div class="toc-item"><a href="#section4">简历和公司匹配度</a></div>
            <div class="toc-item"><a href="#section5">八股文（http）</a></div>
            
        </div>

        
        <h2></h2>
        <pre class="code-block">

        
            
        </pre>
        <div class="section" id="section1"></div>
        <p style="white-space: pre-line;">
            1. shutdown 进入shutdown的状态。 表示线程池正在关闭状态。
            线程池不会接受新任务，继续把队列中的任务处理完。 

            2 stop 
            线程池不会接受新任务了。 
            不会处理队列中的任务。 
            tidying。没有线程在运行。tidying。并且调用terminated。
            该方法是空方法。留给程序员进行扩展。
            五个状态。stop 停止。 不会新任务 也不会处理。 
            synchronized和reentrantlock不同点。 
            java关键字。reentrantlock 提供的类。 需要手动加锁和释放锁。 
            jvm层面的锁。 api层面的锁。
            synchronized 自动加锁和释放锁。 
        
            3  Threadlocal应用场景。线程本地存储
            缓存在线程内部。任意时刻 任意方法中获取缓存的数据。 


            

            4 八股死记硬背

           内存被占用了。
           线程不共享同一个连接。内存泄漏。用完了threadLocal。调用一下remove方法。
           面试题回答的时候要去回答的。

           5 公平锁。非公平锁。
           底层实现。aqs来进行排队。
           lock方法加锁。是否存在线程在排队。


           6 countDownLatch 一个或者多个线程 等待所有线程完成倒计时。
           线程同步协作。
           await用来等待计数归零。
           countDown用来让计数减一。
           es数据批量导入。
           批量导入。查询总条数。计算总页数。db。固定每页两千条。
           分页查询文章数据。查询当前页的文章。 
           es的环境。四个属性。publish 
           es（全文检索 引擎。分布式全文检索引擎。简单的restful api来隐藏lucene的复杂性。
           服务器搭建集群。pb级别的搜索。elasticsearch搜索20tb的数据。
           soundcloud用这个 为1.8亿用户提供即时而精准的音乐搜索服务。
           百度 文本数据分析。 200个es节点。每天导入30+tb的数据。  
           新浪 处理32亿条 实时日志。
           阿里 es构建挖财自己的日志采集和分析体系。


           synchronized锁升级过程是怎么样的
           偏向锁。
           偏向锁。支持锁重入。
           轻量级锁。被获取到了。另外一个来竞争，升级为轻量级锁。没有调用api。而是通过自旋。不会阻塞线程。
           重量级锁 自旋过多仍然没有获取到。升级为重量级锁。导致线程阻塞。
           阻塞和唤醒都要操作系统层面去进行。
           比较消耗时间。

           对守护线程的理解 用户线程就是普通线程。
           守护线程就是离线后自动关闭。
           垃圾回收。parallelism 两个任务同时执行。
           concurrency。两个任务同时执行。底层，任务被拆分成很多份，一个一个执行，站在更高角度看两个任务是同时执行的。

           7  java死锁如何避免。

           8 aqs的理解
           java线程同步的框架 信号量state和线程组成的双向链表队列。
           控制线程排队或者放行。
           state表示加锁的次数。
           0标识无锁。每加一次锁 state就加1 。  
           ioc的理解。


           9 订单网站里 
           电商 订单信息 商品系统。  
           物流信息。订单信息 花费500ms
           商品信息800ms。
           物流信息500ms。
           不同微服务，如何完成这个业务。
           共消耗1800s。
           提交到线程池中执行。
           并行执行的。
           左边串行执行的 互相等待。
           右边并行执行的。
           商品接口完成就行。
           各自500ms。多线程的future特性 获得接口数据。


           搜索对应的场景代码 结合自己的知识点 
           形成一个一小时可复习的模块 作为好的故事进行讲解。


           10 实用场景里，我做过一个es数据导入的任务。
           项目上线前，我要把数据库的数据一次性同步到es索引库里，但是当时的数据好像是1000万左右。一次性读取数据肯定不行（oom异常）
           当时我想到可以用线程池，利用countdownlatch来控制，避免一次性加载过多，防止内存溢出。


           11 客户端 发送http数据包
           根据http协议组装数据包 
           应用层  
           传输层 增加tcp头部。 包含端口号 序列号。 
           网络互联层。增加ip头部。 包含源ip地址。
           网络访问层  增加以太网头部。 
           物理层。  
           分层好处 各层独立。  
           灵活性更好。
           易于测试和维护。  
           能促进标准化。  

           application layer  
           transport layer  
           internet layer  
           network interface layer  
           physical layer 


           12 为什么需要网络 自动化部署 。  
           企业的需求不一样。管理着很多网络设备。
           路由器 交换机 防火墙 负载均衡器。 复杂的业务应用。

           交换机： 多台电脑。 
           router。  三台电脑联网打游戏。
           无线 也要交换机。 无线ap。接收手机的无线信号。 
           防火墙。   


           企业交换机。网络工程师。  政府部门 企业部门。  
           一台几十万 更加复杂丰富的功能。网络 安全稳定可靠。 
           交换机连终端。
           路由器连网络。 
           地址转换 连接不同网络 转换地址。 
           防火墙 个人防火墙。保护一台电脑。防止不安全的数据包被传输。

           负载均衡器。 节点设备 压力平均的水平线上。
           监控节点。 心跳包。正常把数据返回。
           故障发现与故障转移。
           硬件负载均衡器 软件负载均衡器。  
           f5公司的负载均衡器。 内置操作系统和软件 硬件封装。
           绝大多数的企业要求。  
           小盒子。f5 最便宜的十几万 几十万上百万的都有。
           软件负载均衡器 中小公司。成本低。
           java主流。  
           四层代理。  
           七层代理。  

           Network就说自己熟悉tcp和udp 区别在于udp主要是语音视频 tcp主要是无损传输。
           python 
           bash脚本 
           docker部署。 github actions。 workflow。 cicd。  
           linux操作也很熟悉 

           客户端 连接 
           输入流读取数据


           13 共享内存
           线程间共享内存。消息传递的同步是隐式执行的，消息的发送一定在消息的接受之前。
           java采用共享内存模型。隐式通信。显示同步。
           有一个主内存。每个线程有自己的工作内存。
           内存比cpu慢很多，所以要多级缓存，避免等待内存。 


           14 http明文
           易受攻击无法保证数据完整性。 
           https使用ssl加密传输协议。 
           
           15 缓存击穿
           设置了过期时间 给某个key key过期的时候 恰好这时间点对这个key又大量的并发请求过来。
           这些并发的请求可能会瞬间把db压垮。
           添加互斥锁。
           逻辑过期。


           16 线程状态 状态之间如何变化
           尚未启动 可运行 等待 阻塞 终止
           new runnable waiting blocked terminated
           创建线程对象。
           有执行资格。没有执行权。

           17countdownlatch用来让计数器减一
           当时数据大概是两百万 一次性读取肯定内存溢出
           数据库数据一次导入同步到es索引库中。
           线程池方式导入。countdownlatch控制 避免一次导入过多。每页2000条。
           查询总条数。
           批量导入。
           分页查询文章数据。  
           查询当前页的文章。  
           文章任务批量导入es。
           提交到线程池执行。 

           核心线程数
           500ms
           阻塞队列。
           importAll

           18 代理模式 数据恢复到原先的状态
           角色。发起人。记录当前时刻内部状态。访问备忘录所有信息。
           备忘录角色。存储发起人内部状态。 给到发起人
           管理者 对备忘录进行管理 保存和获取。不能修改。
           备忘录。 存储发起人的内部状态。  
           发起人。 创建 memento。
           重置备忘录。  
           管理者字段。  访问备忘录本身 不能修改。 
           优点 恢复状态的机制 实现内部状态的封装。  
           简化。所有状态信息保存在备忘录里面。
           资源消耗大。保存频繁 内存资源占用大。

           19 单例模式
           自行创建 实例模式。
           任务管理器。
           避免打开多个任务管理器 内存资源的浪费。 
           只有一个实例对象。 
           懒汉式单例。
           instance 线程中同步。  
           全局对外的访问点。
           lazysingleton。 
           懒汉式的单例。  
           类加载没有生成单例。  
           创建单例。
           避免类在外部被实例化
           public static synchronized LazySingleton getInstance() {

           }

           hungrySingleton 调用的时候已经存在了。类创建了 静态对象就已经有了。
           直接使用 线程安全的。     
           保证内存当中只有一个实例。
           避免重复创建 减少内存开销。  

           应用场景：保证在一个jvm里面只有一个单一的实例。
           频繁创建一些类 降低内存 需求 只生成一次 更省内存。类的实例化创建时间比较长，但是又不怎么变。

           20 代理模式 
           真实主题的功能 
           request方法。  
           访问真实主题方法。
           访问代理。  
           做了一层封装 调用真实主题里的request。完整的代码。  
           代码增强。  代理初期 两种模式 静态代理 动态代理。
           程序语言代理类 程序运行前 class已经存在了 反射技术 运行的时候创建。

           21  装饰模式
           现有产品加功能 优化外观。
           开发过程里 线程组件 核心功能。  
           动态地扩展功能。  


           22 责任链模式
           事件经过多个对象去处理。
           批假的。  单一职责原则。
           请求没有明确的接收者。


           23 jvm  
           大牛必须掌握jvm。 
           深入理解Java。知道java机制，排查问题的能力。
           内存泄漏 cpu飙高。


           24 python 常错
           string = "app l e"
print(string.split(" "))
#字符串里是一定要有加东西才能用split的
#不加的话 想弄成apple分别5个字符 只能够直接list(string)


25 kafka fault tolerance high availability
in-sync replicas 
synchronous replication
asynchronous replication
followers

channel.confirmSelect确保就是 消息被确认投递成功了

你的生产者 发消息出去对吧
消息队列中间件有一个服务器 对吧 储存你的消息
kafka为了高可用 容错
有很多副本（replica）
但是这里的副本 分为两类
正常的话 我们正常理解 就是有一种是同步的副本
和主服务器所有数据都是一致的
但是这意味着什么呢 就是你每次数据有变更 主服务器都得等待副本备份完 才能继续下一步操作（就是说 主服务器是阻塞的 只要副本同步不完成）
这个优点就是数据一致性能保证 但是呢 副本给主服务器增添了一定负担 因为只要没同步完成 就会阻塞
这些副本叫isr in-sync replica
另外有一些异步同步的replica副本
异步就是它会自己执行 跟你主服务器不相干的 不会阻塞你主服务器的操作
主服务器一般我们叫做leader
这种follower缺点很明显 就是你的leader最新的数据变更 它不一定有 所以保证不了数据一致性
但是优点也有很多 一个点就是
比如isr全部崩溃的时候
这种异步备份的follower就可以拿来用 确保一个高可用
还有的就比如提高了系统的扩展性 比如全球多个地区的服务器 不用一直互相同步 那样有很大的延迟 
它就像是一个 怎么说呢 离线的服务
因为不和leader随时同步的
如果你网络很差或者延迟很大的时候 你的leader和isr之间同步备份是很花时间的
但是因为异步同步的follower是一个异步的原理 所以一直可以用



26 消息不丢失 均摊消费的缺点
告诉服务器端 消费成功
传统队列均摊消费。
生产者10条消息 队列当中。
取1-5 
能者多劳
消费者能力强弱
消费者1和2
默认消费1条或者2条

事务消息。
txSelect.

commit
rollback
txCommit
channel.txCommit()
channel.txRollback()
报错了就会回滚。


27 ack自动与手动ack 应答
自动：高吞吐量（快速处理）
可靠性。
怎么提高消息消费成功率
手动应答。
降低吞吐量。
投递到服务器端有没有成功。
confirm。

28 事务消息
确保 数据一致性和系统稳定性
atomicity
consistency
isolation
durability


29 rabbitmq交换机类型
exchange
direct exchange
fanout exchange
topic exchange
headers exchange
不同的团队
生产者投递给不同的队列 不同的队列给不同的消费者。
交换机 需要一个入口。
路由key 交换机
发布订阅


30 container deployment
不需要虚拟机来部署
直接就是虚拟环境 容器的启动很快 
虚拟机启动太慢了
容器编排 合理利用资源 管理docker集群
swarm docker自己的容器编排。
一个宕机的docker 部署到另外一台。
swarm 原生管理docker 比较简单。
还有除了docker其它的运行环境。
kubernetes 服务发现和负载均衡。
dns名称。direct路由模式。
交换机 路由消息存放。
架构图。
生产者。
routingKeys  
routingKey=email
routingKey=sms


31  rabbitmq direct routing模式是什么
ChatGPT
RabbitMQ 的 Direct Routing 模式是一种消息路由方式，它使用交换机（Exchange）和队列（Queue）来传递消息。在 Direct Routing 模式中，交换机根据发送的消息携带的路由键（routing key）来确定消息应该发送到哪个队列。这种模式通常用于处理路由简单且直接的情况，每个路由键直接对应一个或多个队列。

工作原理：
生产者发送消息：生产者发送消息到 Direct Exchange，并指定一个路由键。
Direct Exchange：交换机接收到消息后，会查看路由键，并根据这个键将消息路由到一个或多个绑定了相应路由键的队列。
消息存储：被路由的消息存储在队列中，直到消费者从队列中提取它们。
应用场景：
Direct Routing 模式非常适用于多种类型任务处理的场景，其中每种类型的任务都需要不同的处理方式。例如，可以根据消息类型将日志信息发送到一个队列、错误消息发送到另一个队列，以便进行分别处理。

这种模式的优点是高效和直接，允许精确控制消息流向特定的队列。缺点是每增加一种消息类型，就可能需要增加新的路由键和队列配置，这可能使配置变得复杂。


virtual hosts类似于不同的topic 不同的团队

32 springboot默认帮助创建交换机 已经弄好了
rabbitmq configure
注入队列到spring容器中
有队列 
交换机

33 springboot整合rabbitmq
rabbit listener和rabbit handler

34 获取消费者结果
投递消息 返回全局id
生成订单号码 发送消息给mq服务器端

mq服务器端 返回一个全局消息id
消费成功 给mq服务器端发通知 标记该消息消费成功
生产者获取消息全局id 每隔2s时间调用mq服务器端接口查询该消息是否有被消费成功。


35 mq死信队列
转移到死信队列 有交换机和路由key等等
生产者-订单交换机-订单队列-死信订单交换机-死信订单队列
订单消费者
死信订单消费者
死信队列架构原理，和普通队列区别不是很大。
都有自己独立的交换机和路由key，队列，消费者。


幂等问题
消息自动重试机制
重试机制
mq重试。一般的mq都会自动重试。自动重试机制
可能引发消费者重复消费的问题。
解决幂等性的问题。
相同的消息。
数据在数据库里重复。
解决幂等（idempotence）：保证数据的唯一。
spring里面max attempt改成5次就可以了

36 什么情况重试 网络延迟 调用接口
网络延迟需要重试
抛出异常
一直报错
消费者指令还是会报错。
代码问题抛出数据异常 不需要做重试。
定时任务实现消息补偿。
人工补偿。

37 幂等性问题
投递的时候 生成一个全局唯一id
消费者 根据唯一id进行消费。


38 dubbo框架




           

           


           
            



            
