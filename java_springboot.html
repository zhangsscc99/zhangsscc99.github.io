<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>以雷霆击碎SpringBoot</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin-top: 50px;
        }
        .main-title {
            color: #007BFF;
            font-size: 2em;
        }
        .description {
            margin-top: 20px;
            font-size: 1.2em;
        }
        .tips {
            margin-top: 40px;
            color: #28a745;
            font-size: 1em;
        }
    </style>
</head>
<body>
    <div class="content">
        <div class="link-to-other-page">
            <a href="index.html">首页/返回</a>
        </div>
        <h1 class="main-title">以雷霆击碎SpringBoot</h1>
        <p class="description">面对编程挑战，我们如同雷霆，击破一切难题。</p>
        <p class="tips">开始你的编程之旅，你的道路没有岔口，因为未来，早已笃定。</p>
        <div class="link-to-other-page">
            <p style="white-space: pre-line;">
                1. protected, private, public, default这样的access modifier都解释一遍 并且用例子说明

                对于public修饰符，它具有最大的访问权限，可以访问任何一个在CLASSPATH下的类、接口、异常等。它往往用于对外的情况，也就是对象或类对外的一种接口的形式。
                这个权限比较高
                protected的权限排第二 不可以被外部包访问，但是子类啥的都行，包括本包和类内部。
                主要作用就是保护子类。
                相当于protected就是传递给子类的
                default的话，一般子类也不可以。只能本包和类的内部。
                而private最严格，本包都不行 只能类的内部可以。
                
                2. 
                @AuthenticationPrincipal User user：
这个注解自动地将当前经过认证的用户注入方法中。在Spring Security环境下，它通常用来获取代表当前用户的User对象。User是Spring Security提供的一个用户详情类，它包含了当前用户的信息，比如用户名、密码和授权
            3. JPA Repository
            JPA Repository refers to a set of interfaces in Spring Data JPA that abstracts away the boilerplate code required to perform CRUD (Create, Read, Update, Delete) operations on entities. When you extend interfaces like JpaRepository, Spring Data JPA automatically provides implementations for methods like save(), findAll(), findById(), deleteById(), etc.
            
            For example, JpaRepository is a JPA-specific extension of the Repository interface that comes with additional JPA-related methods. It provides a way to perform various operations on the entity, including finding, saving, and deleting records without needing to write any implementation code.
            
            These annotations and interfaces significantly reduce the amount of boilerplate code developers 
            @Entity
The @Entity annotation marks a class as a JPA entity. An entity represents a table stored in a database. Every instance of an entity corresponds to a row in the table. This annotation tells the JPA provider that the class should be mapped to a database table.

@Id
The @Id annotation marks a field as the primary key of the entity. The primary key uniquely identifies each entry in the database table. This annotation is placed on the field that maps to the primary key column of the table.

@GeneratedValue
The @GeneratedValue annotation is used in conjunction with @Id to specify the primary key generation strategy for the entity. It indicates that the persistence provider should automatically generate the primary key for the entities. The strategy attribute of @GeneratedValue allows you to select the primary key generation strategy, such as AUTO, SEQUENCE, IDENTITY, or TABLE. AUTO is the default strategy and lets the persistence provider choose the strategy based on the database capabilities.
4.@RestController is a special type of @Controller that contains the semantics of @ResponseBody, which means that the returned object will be automatically serialized into JSON and written into the HTTP response body
5.Why do we need to constantly serialize and deserialize JSON? This process is critical to the functionality of the REST API for several reasons:

Data exchange format: JSON is a lightweight data exchange format that can easily transfer data between different systems. Due to its simplicity and ease of human readability, it has become the de facto standard for data exchange in Web APIs.

Language-independence: JSON is a language-independent data format that does not rely on the specific structure of any programming language. This means that no matter what language the server and client are written in, they can communicate via JSON.

Network transfer: Network transfer usually involves the exchange of data in text format. Serialization converts an object or data structure into a JSON string so that it can be sent over network protocols such as HTTP. In contrast, deserialization converts the received JSON string back into the original object or data structure for use within the program.

Data storage: JSON format is also often used to store data (such as in databases) because it is very readable and concise.

Security: The serialization and deserialization process can serve as a simple form of data validation. When deserializing, you can check whether the JSON data conforms to the expected format, thereby avoiding problems caused by incorrect or malicious data structures.

</p>
        </div>
    </div>
</body>
</html>
