<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>以雷霆击碎SpringBoot</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: left;
            margin-top: 50px;
        }
        .main-title {
            color: #007BFF;
            font-size: 2em;
        }
        .description {
            margin-top: 20px;
            font-size: 1.2em;
        }
        .tips {
            margin-top: 40px;
            color: #28a745;
            font-size: 1em;
        }
    </style>
</head>
<body>
    <div class="content">
        <div class="link-to-other-page">
            <a href="index.html">首页/返回</a>
        </div>
        <h1 class="main-title">以雷霆击碎SpringBoot</h1>
        <p class="description">面对编程挑战，我们如同雷霆，击破一切难题。</p>
        <p class="tips">开始你的编程之旅，你的道路没有岔口，因为未来，早已笃定。</p>
        <div class="link-to-other-page">
            <p style="white-space: pre-line;">
                好课推荐
                https://www.bilibili.com/video/BV1gc41117ta?p=3&spm_id_from=pageDriver&vd_source=d4b859b0532ebb11fd37c3b6f643100f
                1. protected, private, public, default这样的access modifier都解释一遍 并且用例子说明

                对于public修饰符，它具有最大的访问权限，可以访问任何一个在CLASSPATH下的类、接口、异常等。它往往用于对外的情况，也就是对象或类对外的一种接口的形式。
                这个权限比较高
                protected的权限排第二 不可以被外部包访问，但是子类啥的都行，包括本包和类内部。
                主要作用就是保护子类。
                相当于protected就是传递给子类的
                default的话，一般子类也不可以。只能本包和类的内部。
                而private最严格，本包都不行 只能类的内部可以。
                
                2. 
                @AuthenticationPrincipal User user：
这个注解自动地将当前经过认证的用户注入方法中。在Spring Security环境下，它通常用来获取代表当前用户的User对象。User是Spring Security提供的一个用户详情类，它包含了当前用户的信息，比如用户名、密码和授权
            3. JPA Repository
            JPA Repository refers to a set of interfaces in Spring Data JPA that abstracts away the boilerplate code required to perform CRUD (Create, Read, Update, Delete) operations on entities. When you extend interfaces like JpaRepository, Spring Data JPA automatically provides implementations for methods like save(), findAll(), findById(), deleteById(), etc.
            
            For example, JpaRepository is a JPA-specific extension of the Repository interface that comes with additional JPA-related methods. It provides a way to perform various operations on the entity, including finding, saving, and deleting records without needing to write any implementation code.
            
            These annotations and interfaces significantly reduce the amount of boilerplate code developers 
            @Entity
The @Entity annotation marks a class as a JPA entity. An entity represents a table stored in a database. Every instance of an entity corresponds to a row in the table. This annotation tells the JPA provider that the class should be mapped to a database table.

@Id
The @Id annotation marks a field as the primary key of the entity. The primary key uniquely identifies each entry in the database table. This annotation is placed on the field that maps to the primary key column of the table.

@GeneratedValue
The @GeneratedValue annotation is used in conjunction with @Id to specify the primary key generation strategy for the entity. It indicates that the persistence provider should automatically generate the primary key for the entities. The strategy attribute of @GeneratedValue allows you to select the primary key generation strategy, such as AUTO, SEQUENCE, IDENTITY, or TABLE. AUTO is the default strategy and lets the persistence provider choose the strategy based on the database capabilities.
4.@RestController is a special type of @Controller that contains the semantics of @ResponseBody, which means that the returned object will be automatically serialized into JSON and written into the HTTP response body
5.Why do we need to constantly serialize and deserialize JSON? This process is critical to the functionality of the REST API for several reasons:

Data exchange format: JSON is a lightweight data exchange format that can easily transfer data between different systems. Due to its simplicity and ease of human readability, it has become the de facto standard for data exchange in Web APIs.

Language-independence: JSON is a language-independent data format that does not rely on the specific structure of any programming language. This means that no matter what language the server and client are written in, they can communicate via JSON.

Network transfer: Network transfer usually involves the exchange of data in text format. Serialization converts an object or data structure into a JSON string so that it can be sent over network protocols such as HTTP. In contrast, deserialization converts the received JSON string back into the original object or data structure for use within the program.

Data storage: JSON format is also often used to store data (such as in databases) because it is very readable and concise.

Security: The serialization and deserialization process can serve as a simple form of data validation. When deserializing, you can check whether the JSON data conforms to the expected format, thereby avoiding problems caused by incorrect or malicious data structures.
6. why repo?
high-level abstraction. for data access and manipulation. rather writing custom data access code(such as sql queries)
provide a generic api for accessing and manipulating entities. 


Purpose of UserRepository Interface
The UserRepository interface, as an example, is designed to manage the data access operations for User entities. By extending JpaRepository, it inherits a set of methods for performing CRUD (Create, Read, Update, Delete) operations, as well as pagination and sorting functionality. Developers can also define custom query methods in this interface, and Spring Data JPA will automatically provide the implementation based on the method name or the custom query annotation (@Query). This greatly reduces the amount of boilerplate code required to interact with the database.
7 spring, SpringBoot
springboot是spring生态的产品
spring framework是一个容器框架
springboot不是一个框架 快速构建基于spring的脚手架
为开发spring生态其他框架铺平道路
2个不是一个层面的东西 没有可比性
8  springboot的核心注解
java config的配置版本（xml的配置直接跳到springboot的配置方式）
springbootapplication 启动类这里
当前应用是springboot应用
springboot configuration也是一个原注解
启动类是一个配置类
enableautoconfiguration这个注解就是用来启动自动配置类的，扫面所有能使用的自动配置类
自动配置类概念：springboot里的
很多自动配置类里面：autoconfiguration。
conditionalOnProperty
springboot单独提供出来的
conditionalonclass onbean这些都是核心注解

The image you've uploaded appears to be a screenshot of some text explaining various annotations related to Spring Boot's conditional registration of beans. Specifically, the text seems to be describing @Conditional annotations which are a series of annotations that allow you to conditionally register beans in the Spring context based on certain criteria. Let's go over them in English:

@ConditionalOnBean: This annotation is used to conditionally include a bean into the Spring ApplicationContext only if a bean with the specified name is already present in the ApplicationContext.

@ConditionalOnClass: This one is used to register a bean only if the specified classes are present in the classpath. It ensures that the bean will not be created if the required class is not found, preventing class-related errors.

@ConditionalOnExpression: This allows for the inclusion of a bean based on the result of a SpEL (Spring Expression Language) expression. It gives you a powerful way to control bean registration dynamically, based on the evaluation of the expression.

These annotations are part of Spring Boot's auto-configuration magic, which tries to automatically configure your Spring application based on the jar dependencies that you have added. They can be particularly useful for creating auto-configuration classes that conditionally define beans to auto-configure a Spring application according to the presence or absence of certain criteria.
9springboot bean
Yes, you can understand a bean as an object that contains all the information an object would have, and it can indeed be used for passing data, among other functionalities. To make this clearer, let's use a metaphor involving a coffee shop to explain the concept of beans, objects, and their roles within the Spring Framework.

The Coffee Shop Metaphor
Imagine you walk into a coffee shop (the Spring Framework) to get a cup of coffee (an object). This coffee shop is unique because it has a special service (the Spring IoC container) that prepares your coffee for you exactly how you like it without you having to do it yourself.

Coffee Beans (Spring Beans): Just as coffee beans are the essential ingredient to make a cup of coffee, Spring beans are the essential components used by the Spring Framework to create objects. These beans are not simple Java objects; they are special because the Spring container manages them. This means that the container creates these objects, configures them with the right settings (like how you might like your coffee with a specific amount of sugar and milk), and manages their entire lifecycle.

The Recipe (Bean Configuration): Before the coffee shop can make your coffee, they need to know how you like it. This is similar to defining a bean in Spring. You can tell Spring how to create your object (bean), what ingredients (dependencies) it needs, and other settings through configurations. This can be done in various ways, such as XML files, annotations, or Java config classes, much like how you can order your coffee verbally, write it down on a piece of paper, or select options on a touchscreen.

Making the Coffee (Object Instantiation): When you order your coffee, the coffee shop's service (Spring IoC container) goes to work. It takes the coffee beans (Spring beans), follows the recipe (bean configuration), and makes your coffee (object). This process is managed entirely by the coffee shop, so you don't have to grind the beans, boil the water, or mix the ingredients yourself. Similarly, Spring takes care of creating objects and managing them according to the defined configurations, so developers don't have to write boilerplate code for object creation, lifecycle management, and dependency resolution.

Serving the Coffee (Dependency Injection): If your coffee requires milk, the coffee shop adds milk to it before serving. This is like Spring's dependency injection. If a bean needs another bean to work (like a coffee needs milk), Spring ensures that the required bean is created and "injected" into the bean that needs it.

Enjoying Your Coffee (Using the Bean/Object): Finally, you get your coffee exactly how you like it, ready to drink. In your application, the Spring-managed beans are ready to be used wherever needed, configured and assembled according to your specifications.
In this metaphor, the coffee shop takes the responsibility off your hands and ensures your coffee is made correctly, just as Spring manages your objects (beans) and their dependencies, freeing you to focus on the more important parts of your application's logic.


10 springboot的自动配置原理
springbootconfiguration引入了enableautoconfiguration
enableautoconfiguration引入了import
spring容器启动时，加载loc容器会解析import注解
import导入了deferredImportSelector, 会使springboot的自动配置类的顺序在最后，这样方便我们扩展和覆盖
读取所有的meta-inf/spring.factories文件
过滤出所有autoconfigurationclass类型的类
最后通过condition排除无效的自动配置类
11springboot的启动原理
从spring.factories读取listener applicatinContextInitializer
启动类当作配置类传入进行初始化
applicationlistener监听器
推算当前web应用类型webapplicationtype
读取applicationconntextinitializer
new SpringApplication初始化信息
执行.run 加载了ioc容器
refresh方法 体现整个ioc加载过程
servletwebserverapplicationcontext
自动配置类概念：springboot里的记录启动时间
记录启动结束时间
输出启动耗时时间
调用很多监听器对外扩展
读取springapplicationrun监听器
12json stands for javascript object notation. lightweight format for storing and transporting data. 
jason is the most popular format for frontend and backend communications. 
13 how do we return responses in JSON format?
Springboot automcatically converts it to json format for you. 

14public record是什么
在Java中，public record是Java 14中引入的一种新特性，用于简洁地定义数据传输对象（DTO），它能够自动生成字段、构造函数、equals()、hashCode()和toString()方法。public record关键字用于声明一个record类，类似于传统的Java类，但其主要用途是为数据传输而设计的，即不可变的数据聚合。

在你提供的示例中，Person是一个record类，它有四个字段：name、company、homeAddress和favoriteBook。这些字段在声明时没有用private、protected或package-private修饰符修饰，因此它们默认是public的。

记录类不需要编写显式的构造函数，因为它们会自动生成一个公共的构造函数来初始化所有字段。此外，记录类还会自动生成equals()、hashCode()和toString()方法，这些方法会基于记录类的所有字段生成对应的实现。

你的示例中漏掉了record类的主体部分，它应该包含在花括号 {} 中间。在这个部分，你可以添加额外的方法或者其他成员。

15耦合度
耦合度是软件工程中描述模块之间相互依赖程度的概念。它表示一个模块对其他模块的依赖程度，或者说一个模块内部的元素之间的依赖程度。耦合度越低，表示模块之间的独立性越高，修改一个模块不会对其他模块造成太大影响，提高了系统的灵活性、可维护性和可扩展性。

在软件设计中，通常会努力降低耦合度，以提高代码的质量和可维护性。有几种类型的耦合度，包括：

低耦合（Loose Coupling）：模块之间的依赖程度很低，它们之间的关系较为独立，修改一个模块不会对其他模块造成影响。这种情况下，系统的可维护性和可扩展性会更好。

高耦合（Tight Coupling）：模块之间的依赖程度很高，它们之间的关系紧密，修改一个模块可能会导致其他模块的修改。这种情况下，系统的灵活性会受到影响，维护和扩展会更加困难。

无耦合（No Coupling）：模块之间完全独立，彼此没有任何依赖关系。这种情况下，修改一个模块不会影响其他任何模块，但在实际应用中很难实现。

降低耦合度的方法包括使用接口而不是具体实现、使用依赖注入、使用设计模式等。通过合理设计和组织代码，可以有效地降低模块之间的耦合度，提高系统的可维护性和可扩展性。


16
在这段代码中，@RequestParam是Spring框架中的注解，用于从HTTP请求中获取查询参数（Query Parameter）。在hello方法中，locale参数使用@RequestParam注解标记，这表示该参数可以从HTTP请求的查询字符串中提取，并且是可选的（因为设置了required = false）。如果请求中没有提供locale参数，它将默认为"en_US"。

具体来说，@RequestParam注解用于指定要映射到方法参数的查询参数的名称。在这个例子中，locale参数是通过@RequestParam注解指定的，它表示接收名为locale的查询参数的值。

17
create table persons(
    person_id INTEGER,
    last_name text,
    first_name text,
    address text
)
insert into persons(c1, c2, c3, c4) 
values (v1, v2, v3, v4)
values可以是单引号括好的
delete from table where condition 
用;进行结尾


18 springJDBC 和runtimeOnly
Spring JDBC 是 Spring Framework 提供的一个库，用于简化数据库访问和操作。它处理了传统的 JDBC 编程涉及的常见问题，如打开和关闭连接，处理异常，管理资源等。使用 Spring JDBC，开发人员不必编写冗长的代码来执行基本的数据库操作。它提供了一个模板类JdbcTemplate，可以大大减少编码量。

在传统的 JDBC 代码中，开发人员需要写很多样板代码来处理异常、管理事务、关闭连接等。JdbcTemplate接管了这些常规任务，允许开发人员专注于他们的特定数据库逻辑。Spring 还提供了一种声明式的事务管理方式，可以更加灵活地管理事务。

关于runtimeOnly在 Gradle 的 build 脚本中的含义：

Gradle 是一个项目自动构建工具，它用于自动化应用程序的构建过程。在 Gradle 中，依赖管理是非常重要的部分。依赖可以有不同的配置，决定了库是如何在项目的不同阶段中被包含和使用的。

runtimeOnly 是 Gradle 中的一个配置，它意味着这个依赖将不会在编译时被包括，而只会在运行时被包括。这通常用于那些不需要在编译时参与代码的编译过程，但在运行时提供必要功能的库，比如数据库连接驱动。

例如，如果你在 Gradle 的 build 脚本中这样配置 PostgreSQL 的驱动：

groovy
Copy code
runtimeOnly 'org.postgresql:postgresql:版本号'
这意味着 PostgreSQL 驱动只会在运行时被添加到应用程序的类路径中，编译项目代码时不会包含这个驱动。这通常是因为在开发阶段，代码只需要知道 JDBC 接口，并不需要知道特定数据库的实现细节。这样做可以减少构建过程的复杂性，并减小构建产物的大小。在运行时，当应用程序实际连接数据库时，需要具体的数据库驱动来实现连接。


19继续JDBC
JDBC 的全称是 Java Database Connectivity，它是 Java 语言中用于数据库访问的一套API。JDBC 提供了一种基准，允许独立于平台和数据库的数据访问。基本上，JDBC 是一组类和接口（写在 Java 语言中）用于连接 Java 应用程序到各种数据库并执行 SQL 语句，检索结果等。

JDBC 使得开发人员可以通过统一的 API，访问几乎所有的关系型数据库，从而在不必对代码进行大量更改的情况下切换数据库。例如，你可以在开发过程中使用 SQLite 或 H2 这样的内存数据库，然后在生产环境中切换到 MySQL 或 PostgreSQL，而代码的其他部分不需要（或只需要很少的）修改。

JDBC API 主要包括两部分：

JDBC Driver API：允许一个应用程序连接到数据库，发送 SQL 语句，处理结果等。
JDBC Management API：用于管理数据库连接的环境，通常是开发人员不直接使用，而是通过诸如 Spring JDBC 或 JPA 这样的高层框架间接使用。
数据库厂商会为自己的数据库系统提供 JDBC 驱动程序，这些驱动程序是 JDBC API 规范的实现，确保 Java 应用程序可以与其数据库通信。


20 bq
bq的面试里 最好是技术相关的项目。
虽然是intern和new grad 但是技术相关的最重要。
除非是面试问到没准备的问题 非技术 
不然全都是技术相关的项目。

在一个繁忙的运动赛事管理软件公司工作时，我曾面对一个重大的挑战：数据库性能优化。这是一个承载着数以万计用户数据的系统，每天都有成百上千的赛事更新，数据量之大让原有的数据库架构喘不过气来。作为负责人，我需要采取措施，优化这一关键基础设施。

那个时候，用户反映数据加载缓慢，后台管理任务频繁延误。问题定位于数据库冗长的查询时间和不足的并发处理能力。深入分析后，我发现一些核心问题：过时的索引、未优化的查询和表结构不合理。其中，event_schedule 和 event_member 这两个表是最常访问和更新的表，而这正是性能瓶颈的所在。

我决定重构数据库索引，设计一个自动化的脚本来定期重新评估和更新索引，使得查询更为高效。我用EXPLAIN ANALYZE对最慢的查询进行了诊断，并重写了这些查询，以减少表扫描并提高响应时间。更为重要的，我设计了新的表结构，添加了必要的外键约束，以保持数据完整性并提高查询性能。

举个例子，我对event_schedule表执行了一个关键的更改，去除了一个冗长的字符字段selected_sport_type_name，转而使用与sport_type表关联的整数ID字段。这一改动不仅缩短了查询时间，还减少了数据冗余，并使得未来的扩展更为灵活。

这项工作是一个逐步的过程，我每天都在监控性能指标，并根据反馈进行调整。随着这些变化的实施，系统的响应时间明显缩短，用户满意度得到了显著提升。最终，通过这些改进，数据库的处理速度提高了约50%，并发处理能力增强，为公司赢得了更多的客户信任和业务增长。这次经历不仅让我对数据库性能优化有了深刻的认识，还锻炼了我的问题解决能力和项目管理技能。
reorganize the index of the database. 
write an automated script to periodically reestimate and update index to make the query moreeffective.
intern不需要说太多太深的东西给自己露怯。太深了反而给自己挖坑。主要是故事要说好。
前期分析，项目层面上的设计，ui设计和页面逻辑。
写sprint文档/spike -> ticket
sprint文档


21 help peers bq / conflicts bq
pros and cons 都要说

22 分片传输的试探
十片 一片一片传输
分片的上传
大文件传输。
极速秒传。
shardSize. shardIndex. 
getFileShard (shardIndex, shardSize) {
    let _this = this;
    let file = _this.$refs.file.files[0];
    let start = (shardIndex - 1) * shardSize;	//当前分片起始位置
    let end = Math.min(file.size, start + shardSize); //当前分片结束位置
    let fileShard = file.slice(start, end); //从文件中截取当前的分片数据
    return fileShard;
  },
  shard相关
  需要拿到file，拿到start和end，用slice得到shard过的file
  用key唯一标识一个文件

  23 restcontroller:
  handle http requests . 
  shorthand for controller(instead of view). responsebody. 
  responsebody tells a controller that the object returned is automatically serialized into JSON and passed
  back into the httpresponse object. 

  @Controller
@RequestMapping("/api")
public class MyController {

    @RequestMapping(value = "/items", method = RequestMethod.GET)
    public ResponseEntity<List<Item>> getItems() {
        // ... get items logic ...
    }

    @RequestMapping(value = "/items", method = RequestMethod.POST)
    public ResponseEntity<Item> addItem(@RequestBody Item item) {
        // ... add item logic ...
    }

    @RequestMapping(value = "/items/{id}", method = RequestMethod.PUT)
    public ResponseEntity<Item> updateItem(@PathVariable("id") Long id, @RequestBody Item item) {
        // ... update item logic ...
    }

    @RequestMapping(value = "/items/{id}", method = RequestMethod.DELETE)
    public ResponseEntity<Void> deleteItem(@PathVariable("id") Long id) {
        // ... delete item logic ...
    }
}


24 不涉及安全性的数据我们可以交给前端来做 不然后端服务器压力太大了。


25
JSON的优点：
轻量级: 相比于XML，JSON的数据格式更加轻巧，因为它不使用结束标签，并且格式更为紧凑。

可读性: 对于人类和机器来说，JSON格式都是易读和易写的。

易于解析: 大多数编程语言都有解析JSON的库，这些库通常很容易使用，并且可以快速转换成语言中的原生数据类型。

结构灵活: JSON可以表示列表、数组、键值对等数据结构，这给数据表示提供了灵活性。

网络传输高效: 由于其轻量，它在网络上传输更快，减少了数据传输的负担。

数据交互性: 作为Web开发中的标准，它在不同的网络平台之间提供了很好的数据交互性。

JSON的缺点：
安全性: JSON本身不包含任何安全性，容易受到跨站点脚本（XSS）攻击。

不支持注释: JSON标准不支持注释，这可能使得配置文件或复杂JSON结构的理解和维护变得困难。

数据类型限制: JSON支持的数据类型有限，不包括日期、时间等数据类型，这需要在序列化和反序列化时进行额外的处理。

冗余: 对于每个数据值，JSON都要求一个键，这可能会在格式中引入一些冗余。

读取复杂性: 对于嵌套深且复杂的JSON数据，读取和理解起来可能会比较困难。

没有版本控制: JSON格式没有提供版本控制，随着API的发展，保持向后兼容性可能会比较困难。


26 DTO只是用于data transfer的 不可代替实际的object  
所以dto可用作真正的实际对象吗
ChatGPT
DTO（Data Transfer Object）的主要目的是用作数据的容器，用于在应用程序的不同层（例如表示层和服务层）之间传输数据。它们通常不包含任何业务逻辑，只包含数据的getter和setter方法。

在软件架构中，DTO不应该被当作领域模型（实际的业务对象）使用。领域模型通常包含业务逻辑，表示应用程序状态的规则和行为。DTOs仅仅是从一个层传输到另一个层的数据的简单结构表示。

例如，您可能有一个领域模型User，它包含业务逻辑，如验证用户密码或更新用户状态。而UserDTO可能只是包含用户数据，如用户名和电子邮件，用于通过API层传递信息。

这里是User领域模型与UserDTO的一个比较：

java
Copy code
// 领域模型示例
public class User {
    private String username;
    private String hashedPassword;
    private String email;

    public User(String username, String rawPassword, String email) {
        this.username = username;
        this.hashedPassword = hashPassword(rawPassword);
        this.email = email;
    }

    // 业务逻辑方法
    public boolean checkPassword(String rawPassword) {
        return hashPassword(rawPassword).equals(this.hashedPassword);
    }

    // ... 更多业务逻辑 ...

    // Getters and Setters
}

// 数据传输对象示例
public class UserDTO {
    private String username;
    private String password; // 注意，这里不是hashedPassword
    private String email;

    // 只有简单的Getters and Setters
}
在上面的例子中，User类包含了如何处理密码哈希的逻辑，而UserDTO只是简单地传递了未处理的密码。这样，DTO就可以在用户注册或者登录的HTTP请求中传递用户信息，而不需要包含任何业务逻辑。

总结，DTO不是用来替代真正的实际对象的，而是用作在不同系统层之间传输数据的一个便利工具。它们有助于简化方法签名，并提高层之间的数据传输效率。


27
@PostMapping("/auth/login")
public ResponseEntity<ResponseDTO> loginUser(@RequestBody LoginDTO loginDTO) {
    // 登录验证逻辑
    String token = authenticationService.authenticate(loginDTO.getUsername(), loginDTO.getPassword());
    ResponseDTO responseDTO = new ResponseDTO(true, "User logged in successfully.", token);
    return ResponseEntity.ok(responseDTO);
}
#这里的ok就是状态码吗
ChatGPT
是的，在Spring框架中，ResponseEntity.ok() 方法是一种快捷方式，用于创建一个ResponseEntity对象，它将会带有HTTP状态码200 OK。这个状态码表示请求已成功处理。

在您的例子中，loginUser 方法在验证用户凭证并成功生成JWT令牌后，会使用ResponseEntity.ok()来构建一个带有状态码200 OK的响应。该方法还包装了一个ResponseDTO对象，这个对象包含了操作成功的标识、消息以及新生成的JWT令牌。

ResponseEntity是一个泛型类，允许您定义返回类型。ok()方法实际上是ResponseEntity的一个静态辅助方法，它创建了ResponseEntity的一个实例并将其状态码设置为HttpStatus.OK。您可以传入任何类型的身体对象，它将作为HTTP响应的主体返回。

这样的设计既清晰又方便，允许您在不同的情况下构建具有不同状态码和主体的HTTP响应，这是构建RESTful服务时非常常见的做法。










</p>
        </div>
    </div>
</body>
</html>
