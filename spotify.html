<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spotify Clone</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        .main-title {
            color: #007BFF;
            font-size: 2em;
            text-align: center;
        }
        .content {
            margin-top: 20px;
        }
        .code-block {
            background-color: #f4f4f4;
            border-left: 3px solid #007BFF;
            padding: 10px;
            margin: 20px 0;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .link-to-other {
            display: block;
            margin-top: 20px;
            text-align: center;
            font-size: 1em;
            color: #28a745;
        }
    </style>
</head>
<body>
    <div class="content">
        <div class="link-to-other-page">
            <a href="index.html">首页/返回</a>
        </div>
        <h1 class="main-title">链表专题</h1>
        <p></p>
        <div class="toc">
            <h2>Table of Contents</h2>
            <div class="toc-item"><a href="#section1">3.1 - 3.7</a></div>
            <div class="toc-item"><a href="#section2">1 RequestParam</a></div>
            <div class="toc-item"><a href="#section3">2 SpringDataJPA</a></div>
            <div class="toc-item"><a href="#section4">3 Interceptor</a></div>
            <div class="toc-item"><a href="#section5">2 两数相加</a></div>
            <div class="toc-item"><a href="#section6">92 反转链表II</a></div>
            <div class="toc-item"><a href="#section7">141 环形链表</a></div>
            <div class="toc-item"><a href="#section8">142 环形链表II</a></div>
            
        </div>

        <div class="section" id="section1"></div>
        <h2>3.1 - 3.7</h2>
        <pre class="code-block">
            
        </pre>
        <p>今天开始 项目 计划一天2小时 大概为期两周做完
        <p>

            <div class="section" id="section2">RequestParam的知识点</div>
        <h2>1 RequestParam的知识点</h2>
        <pre class="code-block">
            
        </pre>
        <p>在某种程度上，是的。@RequestParam注解作为Spring框架中常用的注解之一，为处理HTTP请求中的参数提供了便捷的方式。它简化了从HTTP请求中获取参数值的过程，并提供了灵活的方式来处理这些参数。

            使用@RequestParam注解，你可以将参数直接注入到控制器方法的参数中，而无需手动解析HTTP请求，这使得代码更加简洁和可读。同时，@RequestParam注解还提供了一些参数，例如required参数用于指定参数是否是必需的，默认为true，如果设置为false，则表示参数是可选的。
            
            虽然在某种程度上它可能看起来有些神奇，但实际上它只是Spring框架提供的一个方便的工具，用于处理HTTP请求中的参数，让我们能够更专注于业务逻辑的实现。
        <p>

            <div class="section" id="section3"></div>
        <h2>2 spring data jpa</h2>
        <pre class="code-block">
            
        </pre>
        <p>
            在Spring Data JPA中，findByEmail方法并不需要在 UserRepository 接口中定义。Spring Data JPA 根据方法名的约定自动生成查询语句，只要方法名按照一定的规则命名，Spring Data JPA 就能够自动识别并生成对应的查询。
            
            在上述代码中，findByEmail方法的命名规则遵循了Spring Data JPA的约定：findBy表示根据某个字段查询，Email表示要查询的字段是email。因此，Spring Data JPA会根据这个方法名自动生成一个查询语句，用来查询User实体中email字段等于指定值的记录。
            
            这种命名约定的好处是可以大大简化查询方法的定义，不需要手动编写查询语句，Spring Data JPA会根据方法名自动生成对应的查询，提高了开发效率。
            
            User
            为什么那么神奇 是ai做的吗
            ChatGPT
            不完全是。Spring Data JPA 的查询方法名约定确实是一种非常方便的功能，但它并不是由人工智能（AI）设计的。这个功能是由Spring Data团队设计和开发的，旨在简化开发人员对JPA的使用。
            
            Spring Data JPA 的目标之一是减少开发人员需要编写的样板代码，并提供一种更简洁、更易于使用的方式来访问数据库。查询方法名约定就是其中之一，它使得开发人员只需要按照一定的规则命名方法，就能够自动地生成对应的查询语句，而不需要手动编写繁琐的查询语句。
            
            虽然这个功能看起来可能有些神奇，但实际上它只是通过一系列的设计和实现，使得开发人员能够更轻松地使用Spring Data JPA来访问数据库。这种功能的设计背后是软件工程和数据库领域的最佳实践和设计原则，而不是人工智能。 <p>

            <div class="section" id="section4"></div>
            <h2>3 Interceptor</h2>
            <pre class="code-block">
                
            </pre>
            <p>拦截器（interceptor）通常指的是在软件开发中用于拦截和处理请求的组件或模块。在不同的上下文中，拦截器可能有不同的功能和用途，但其基本原理是拦截进入或离开某个组件或系统的请求，并在请求被处理前或处理后执行一些额外的逻辑。

                在Web开发中，拦截器通常用于拦截HTTP请求或响应，以执行一些预处理或后处理操作，例如身份验证、日志记录、性能监控、安全检查等。框架如Spring MVC中常用拦截器来实现这些功能。
                
                在网络安全领域，拦截器可以用于拦截恶意流量、检测和防止攻击、实施访问控制等。
                
                在软件设计中，拦截器也可以用于实现面向切面编程（AOP），通过拦截方法调用实现横切关注点的封装，例如事务管理、日志记录等。
                
                总的来说，拦截器是一种通用的编程模式，用于在软件系统中实现各种类型的拦截和处理逻辑，以增强系统的功能、安全性和可维护性。
                用来处理拦截逻辑，增强系统的安全性，可维护性，增强功能。

                如果北美SDE面试官问你什么是“interceptor”，你可以用以下方式用英文回答：

An interceptor is a component or module used in software development to intercept and handle requests. It intercepts incoming or outgoing requests to a component or system and performs additional logic before or after the request is processed. In the context of web development, interceptors are commonly used to intercept HTTP requests or responses to perform tasks such as authentication, logging, performance monitoring, security checks, and more. They provide a way to execute cross-cutting concerns such as transaction management and logging. Overall, interceptors are a versatile programming pattern used to implement various types of interception and processing logic in software systems to enhance functionality, security, and maintainability.
In the context of a login functionality, interceptors play a crucial role in enhancing security and managing user sessions. Here's how you can explain the role of interceptors in the login process:

Interceptors intercept HTTP requests before they reach the intended endpoint, in this case, the login endpoint. When a user attempts to log in, the request is intercepted by the interceptor before it reaches the login handler. Here are some specific functions interceptors can perform in the login process:

Authentication: Interceptors can verify the user's credentials included in the login request. This authentication process ensures that the user is who they claim to be before allowing access to protected resources.

Authorization: After authenticating the user, interceptors can check whether the authenticated user has the necessary permissions to access the requested resource. This authorization step ensures that only authorized users can proceed with the login process.

Session Management: Interceptors can manage user sessions by generating and validating session tokens or cookies. Upon successful authentication, an interceptor can create a session token for the user and attach it to subsequent requests. It can also validate the session token to ensure that the user's session remains active and valid.

Logging: Interceptors can log login attempts and other relevant information for auditing and security purposes. This logging can include details such as the user's IP address, timestamp of the login attempt, and whether the login was successful or not.

Error Handling: Interceptors can handle errors that may occur during the login process, such as invalid credentials or server errors. They can return appropriate error messages to the client, providing feedback to the user and helping troubleshoot issues.

</p>
            

    <div class="section" id="section5"></div>
    <h2>generic types</h2>
    <pre class="code-block">
        
    </pre>
    <p>Parameterized Type: A parameterized type is a class or interface that uses type parameters. For example, ArrayList<T> uses the type parameter T to represent the type of elements it can hold.

        Type Parameter: Type parameters are placeholders for actual types. They are specified within angle brackets (<>) when declaring a generic type. Common type parameter names include T, E, K, and V.
        
        Generic Class: A generic class is a class that declares one or more type parameters. These parameters can be used throughout the class definition to represent different types. For instance, ArrayList<T> can store elements of any type.
        
        Generic Interface: Similar to generic classes, generic interfaces declare type parameters that can be used within the interface definition. Implementing classes must specify the actual types for these parameters.
        
        Generic Method: Generic methods are methods that declare their own type parameters. They can be used to operate on objects of any type. For example, a method public <T> T getFirst(List<T> list) can return the first element of any list.
        
        Wildcard: Wildcards are used to represent unknown types. They are denoted by the ? symbol and can be used as type arguments to increase flexibility.
        
        Type Erasure: Java's generics are implemented through type erasure, meaning that type information is removed during compilation. This allows for compatibility with older Java code but also means that generic type information is not available at runtime.
        </p>

        <div class="section" id="section6"></div>
        <h2>泛型</h2>
        <pre class="code-block">
            
        </pre>
        <p>泛型在java中有很重要的地位，在面向对象编程及各种设计模式中有非常广泛的应用。

            什么是泛型？为什么要使用泛型？
            
            泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。
            
            泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。
            ————————————————
            
                                        版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
                                    
            
        </p>

            <div class="section" id="section7"></div>
            <h2>141 环形链表</h2>
            <pre class="code-block">
                public class Solution {
                    public boolean hasCycle(ListNode head) {
                        ListNode fast = head;
                        ListNode slow = head;
                
                        while (fast != null && fast.next != null) {
                            fast = fast.next.next;
                            slow = slow.next;
                            if (fast == slow) {
                                return true;
                            }
                
                        }
                        return false;
                    }
                }
            </pre>
            <p>快慢指针的while循环条件一般都是这个。
            <p>

    <div class="section" id="section8"></div>
    <h2>142 环形链表II</h2>
    <pre class="code-block">
        public class Solution {
            public ListNode detectCycle(ListNode head) {
                ListNode fast = head;
                ListNode slow = head;
        
                while (fast != null && fast.next != null) {
                    fast = fast.next.next;
                    slow = slow.next;
                    if (slow == fast) {
                        break;
                    }
                }
        
                if (fast == null || fast.next == null) {
                    return null;
                }
        
                fast = head;
        
                while (fast != slow) {
                    fast = fast.next;
                    slow = slow.next;
                }
        
                return slow;
                
            }
        }
    </pre>
    <p>先找到环里相交的点。然后此时把fast重新设置回head。注意 fast行走距离2k，slow行走距离k，假设交点距离环的起点距离m，那么head距离环的起点就是k - m。
        此刻，如果fast从头开始到环的起点，slow也同步从交点开始行走，那么他们在环的起点可以相遇而且正好走了k-m距离。这个可以用作结论记住。
    <p>
    </div>
</body>
</html>
