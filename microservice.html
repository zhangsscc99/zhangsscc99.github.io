<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>图论专题</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        .main-title {
            color: #007BFF;
            font-size: 2em;
            text-align: center;
        }
        .content {
            margin-top: 20px;
        }
        .code-block {
            background-color: #f4f4f4;
            border-left: 3px solid #007BFF;
            padding: 10px;
            margin: 20px 0;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .link-to-other {
            display: block;
            margin-top: 20px;
            text-align: center;
            font-size: 1em;
            color: #28a745;
        }
    </style>
</head>
<body>
    <div class="content">
        <div class="link-to-other-page">
            <a href="index.html">首页/返回</a>
        </div>
        <h1 class="main-title">MapReduce</h1>
        <p></p>
        <div class="toc">
            <h2>Table of Contents</h2>
            <div class="toc-item"><a href="#section1">面试经验</a></div>
            <div class="toc-item"><a href="#section2">3月学习计划</a></div>
            <div class="toc-item"><a href="#section3">简历修改和公司调查</a></div>
            <div class="toc-item"><a href="#section4">简历和公司匹配度</a></div>
            <div class="toc-item"><a href="#section5">八股文（http）</a></div>
            
        </div>

        
        <h2></h2>
        <pre class="code-block">

        
            
        </pre>
        <div class="section" id="section1"></div>
        <p style="white-space: pre-line;">
            1. 服务集群  
            分布式缓存。 分布式搜索。
            服务网关。
            消息队列。  
            分布式日志服务。 
            系统监控。链路追踪。 
            配置中心，注册中心。jenkins微服务项目自动化部署，k8s。

            完整的微服务技术栈。
            jenkins k8s

            实用篇。
            高级篇 微服务技术难点。 复杂技术。


            2 认识微服务实现
            spring cloud。  
            所有功能集中在一个项目中开发，打成一个包部署 
            架构简单 部署成本低
            耦合度高

            分布式架构  
            业务功能对系统做拆分。每个业务作为独立项目开发。称为一个服务。
            降低服务耦合。有利于服务拓展。

            拆分问题：部署在独立机器上，一个向另一个发请求，跨越机器的调用。
            服务拆分粒度。服务集群地址如何维护？
            服务之间如何实现远程调用。
            服务健康状态如何感知。
            dubbo是什么呢，分布式技术。
            升级迭代，微服务方案比较火。
            经过良好架构设计的分布式架构方案，微服务架构特征。
            拆分粒度小，每个服务对应唯一的业务能力，单一职责，避免重复业务开发。
            进一步拆分。

            微服务对外暴露业务接口。
            面向服务。部署独立，数据独立，技术独立，团队独立。
            按照微服务派发。前端，服务端，测试，运维，5-8人都行。服务迭代升级，快速定下来。
            会员服务，用户服务，积分服务。擅长的技术。自己随便选，大家术业有专攻。
            数据库。  
            隔离性强。服务调用做好隔离，容错，降级，避免出现级联问题。
            高内聚，低耦合。架构非常复杂，运维，监控，部署难度提高。

            微服务落地技术。springcloud和阿里巴巴的dubbo。
            微服务拆分，集群。接口暴露。调用。
            服务集群，注册中心，维护各个节点状态。
            配置中心，管理整个微服务群的配置。
            微服务上线，访问。服务网关。请求路由，负载均衡。
            

            dubbo 服务远程调用 dubbo协议。  
            zookeeper，redis是注册中心，没有配置中心。没有服务网关。dubbo-admin，功能弱。
            spring cloud集大成者。eureka，consul。feign http协议。
            sringcloud gateway，zuul。
            服务网关gateway，响应式服务，吞吐能力非常强。
            SpringCloud的开源组件的集大成者。
            SpringCloudAlibaba，nacos, eureka, dubbo, feign, springcloudconfig, nacos, 
            springcloudgateway, zuul, sentinel, 
            hystrix服务监控和保护。


            3 springcloud 最广泛的微服务框架。
            app登录 手动加密 md5 + 随机字符串  
            md5基础上手动加盐处理。 salt。  
            根据用户生成salt，随机字符串。 
            根据用户名查询用户。
            用户输入密码加数据库中的salt md5加密。 
            比对密码。 


            4 要见多识广 技术面光 业务面广
            web3的知识也要了解 blockchain。aigc。
            chatgpt。LLM。  


            5  nacos: 服务发现和配置管理 
            构建云原生应用。
            动态服务发现和配置管理问题。
            动态dns服务。
            分布式服务协调系统。zookeeper。 
            解决一致性问题。 
            协调分布式应用的中心化服务。


            为什么在linux系统里启动nacos服务
ChatGPT
在 Linux 系统上启动 Nacos 服务是常见的做法，原因涉及到多个方面，包括 Linux 系统的稳定性、性能、安全性、以及开源社区的支持等。下面是一些具体的原因为什么在 Linux 系统里启动 Nacos 服务是一个好的选择：

稳定性和可靠性：Linux 系统以其稳定性和可靠性而闻名，这对于确保 Nacos 服务的连续运行非常重要。服务发现和配置管理作为微服务架构的核心组件，需要24/7不间断运行，Linux 提供了这方面的保障。

性能：Linux 系统通常能提供比其他操作系统更好的性能。Linux 内核和网络栈都经过优化，能够处理大量并发连接和高吞吐量，这对于 Nacos 这样的中间件来说是非常重要的。

安全性：Linux 提供了强大的安全特性，如 SELinux、AppArmor 以及各种网络安全机制，有助于保护 Nacos 服务免受攻击。

开源和成本效益：Linux 是开源的，这意味着你可以自由使用而不需要支付额外的许可费用，这对于希望降低成本的企业尤其重要。同时，Nacos 也是开源的，两者搭配使用可以最大化地降低成本。

社区支持：Linux 有一个庞大且活跃的开源社区，可以为遇到问题的用户提供支持和解决方案。同样，Nacos 也拥有一个活跃的社区，用户可以从中获得帮助和最佳实践分享。

灵活性和可扩展性：Linux 系统提供了极高的灵活性和可配置性，用户可以根据自己的需要进行定制和优化。这使得 Linux 成为运行 Nacos 等需要高度定制化设置的中间件的理想选择。

环境一致性：在开发和生产环境中使用相同的操作系统（如 Linux）可以避免许多环境不一致导致的问题。由于 Linux 在云环境和数据中心中的广泛应用，使用 Linux 可以使得从开发到部署的过程更加顺畅。

基于以上原因，在 Linux 系统中启动 Nacos 服务是十分常见和推荐的做法，特别是在需要高性能、高可靠性和高安全性的生产环境中。


6 mybatis是什么 
mybatis是什么
ChatGPT
MyBatis 是一个流行的 Java 持久层框架，它提供了对象关系映射（ORM）的功能，允许将 Java 对象与数据库中的表进行映射，从而简化了数据库操作。与其他 ORM 框架如 Hibernate 相比，MyBatis 提供了更为直接和简单的方式来处理数据库操作，它允许开发者通过编写 SQL 语句来进行精细的数据库操作控制，而不是完全依赖于框架生成的 SQL。

MyBatis 的关键特点包括：
简单易用：MyBatis 的配置和使用都比较简单，开发者可以很容易地集成 MyBatis 到现有的项目中，并快速开始工作。

灵活：MyBatis 允许开发者直接编写 SQL 语句，这为处理复杂的数据库操作提供了极大的灵活性。开发者可以根据需要优化 SQL，以获得更好的性能。

动态 SQL：MyBatis 支持动态 SQL 语句的构建，使得 SQL 语句的编写更加灵活和强大。这对于需要根据不同条件生成不同 SQL 语句的场景特别有用。

映射器（Mapper）：MyBatis 通过映射器将 Java 方法与 SQL 语句关联起来，这使得数据库操作更加直观和类型安全。映射器可以是 XML 文件或者接口加注解的形式。

会话管理：MyBatis 提供了会话管理和事务控制的功能，允许开发者在需要的时候进行事务管理和会话控制。

集成支持：MyBatis 可以与 Spring、Spring Boot 等流行的 Java 框架无缝集成，这使得在这些框架中使用 MyBatis 变得非常方便。

使用场景：
MyBatis 特别适用于那些对数据库操作有特殊需求，需要手写 SQL 以获取更高性能或处理复杂查询的项目。由于它允许直接控制 SQL 语句，因此对于那些需要细粒度控制数据库交互的应用来说，MyBatis 是一个很好的选择。

总的来说，MyBatis 是一个强大且灵活的 ORM 框架，它结合了直接使用 SQL 的灵活性和 ORM 的便捷性，适用于各种规模的 Java 应用项目。

7 所有微服务结构都类似。  
loginDto.  
login_auth.  
接口定义。版本号方便配置。
ResponseResult.  
Post请求方式。  
数据库分页查询。


8 接口分析
idea功能实现。



9 service接口解耦代码
mapper是一个接口。 mybatis里。
mapper
什么是 mapper： 在 MyBatis 中，mapper 是一个接口，它定义了与数据库交互的方法。这些方法直接对应于 SQL 语句。每个方法都关联了一个在 mapper XML 文件中定义的 SQL 语句，或者是注解中定义的 SQL。当你调用这个接口的方法时，MyBatis 会执行对应的 SQL 并返回结果。

为什么是接口： MyBatis 使用接口加 XML 或注解的方式来定义 mapper，这样做有几个好处。首先，它实现了关注点分离，SQL 和 Java 代码被分开管理。其次，接口为动态代理提供了可能，MyBatis 在底层创建了这个接口的代理实现，在这个代理中注入了 SQL 执行的逻辑。这使得代码更加简洁，并且更易于维护和测试。

service
service 接口： 在 Spring 或类似的框架中，service 层通常用于定义业务逻辑的抽象。接口定义了应该完成的任务和操作，但不涉及具体的实现。

service 实现类（impl）： 实现类 ApUserServiceImpl 是 ApUserService 接口的具体实现。它包含了实际的业务逻辑，调用 mapper 层的接口与数据库进行交互。

为什么 service 还得是接口： 将 service 定义为接口有几个原因。首先，它为不同的实现提供了可能性，这在多种实现必须根据不同情况替换时非常有用。其次，它有助于解耦代码，因为高层模块（如控制器或其他服务）只依赖于抽象，而不是具体的实现，这样有助于测试和后续的代码维护。最后，接口也有利于使用 Spring 的依赖注入特性，提高代码的模块性和灵活性。

简而言之，这种使用接口定义层次和职责的架构风格，有助于保持代码的整洁和可维护性，同时为测试、调试和后续可能的功能扩展提供便利。


10 动态代理  
功能扩展提供便利。

User
什么是动态代理
ChatGPT
动态代理是一种设计模式，它允许程序在运行时动态地创建代理类和代理对象。在 Java 中，动态代理通常通过 java.lang.reflect.Proxy 类和 java.lang.reflect.InvocationHandler 接口来实现。这种机制使得你可以在运行时创建一个实现了一或多个接口的代理对象，而不需要为每个接口编写实现类。

这个代理对象在所有方法调用上作为一个中间层，可以用来进行方法拦截、方法调用前后执行额外的处理（比如日志记录、权限检查、事务处理、延迟加载等），然后根据需要将调用转发到实际对象。

动态代理的工作原理
定义一个接口：你有一个或多个方法的接口定义。
创建 InvocationHandler：实现 InvocationHandler 接口，定义一个调用处理器，它将决定代理对象的方法调用如何被处理。
创建代理对象：通过 Proxy 类的 newProxyInstance 方法动态创建代理对象，这个方法需要三个参数：类加载器、一组接口以及刚才创建的调用处理器。
使用代理对象：使用返回的代理对象就像使用其它任何实现了接口的对象一样。
动态代理的用途
动态代理在许多场景中都很有用，例如：

AOP（面向切面编程）：在 AOP 中，动态代理可以用来实现方法的拦截，为方法调用提供事务管理、日志记录、权限检查等横切关注点。
测试和模拟：动态代理可以用来动态创建模拟对象，用于测试没有实现类的接口。
远程方法调用（如 RMI、RPC）：动态代理可以代理远程对象，使得调用远程方法就像调用本地方法一样。
数据库ORM框架：如 MyBatis，使用动态代理技术生成 Mapper 接口的实现，从而避免了手动编写 DAO 实现的工作。


11 dao(hibernate, spring jpa), dto, mapper(mybatis), entity
在 Spring 框架的上下文中，DAO（Data Access Object）通常指的是一个旧的模式，用于封装数据库操作的代码。而当你提到 Spring Data JPA 或 Spring Data JDBC 的 repository 接口时，它们实际上是 DAO 的一种现代替代品，提供了更高级的数据持久层抽象。

Repository Interface
Spring Data 提供了 Repository 接口，这是一种高级抽象，它封装了数据存储的访问逻辑。Spring Data Repository 接口的目的是简化数据访问层的代码，并减少样板代码。在 Spring Data JPA 中，这通常与 ORM 框架如 Hibernate 配合使用；在 Spring Data JDBC 中，它直接与数据库交互。

Repository 的特点
减少样板代码：Spring Data Repository 接口可以自动实现许多常见的数据访问操作，无需编写实现代码。
方法签名查询：你可以通过定义方法签名来创建查询，Spring Data 会提供实现。例如，findByUsername(String username) 就会生成一个根据用户名查询的操作。
支持多种存储策略：Spring Data 提供了对不同数据存储策略的支持，比如关系数据库、NoSQL 数据库、REST API 等。
Repository 接口与 DAO 的对比
DAO：传统上用于抽象化数据访问逻辑，通常需要手动编写实现和管理 SQL 语句或 ORM 实体。
Repository：在 Spring Data 中，是一种更高级的抽象，它扩展了 CrudRepository 或 PagingAndSortingRepository 接口。它们通常不需要显式的实现，因为 Spring Data 可以根据方法命名策略自动提供实现。
在 Spring Data 中，repository 接口扮演了 DAO 的角色，但以一种更声明性和更少编码的方式来实现。你不需要写实现类；Spring Data 会为你的接口生成代理实现，执行必要的数据库操作。这使得数据访问层更加简洁，易于开发和维护。




12
事务的概念
事务通常指的是一组必须作为一个整体执行的操作序列，它们要么全部成功，要么全部失败。在数据库管理系统中，事务必须满足 ACID 属性，即原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。

原子性：事务中的所有操作要么全部执行，要么全部不执行。
一致性：事务执行的结果必须使数据库从一个一致性状态转换到另一个一致性状态。
隔离性：并发执行的事务彼此独立，不会互相干扰。
持久性：一旦事务提交，其结果就是永久性的，即使发生系统故障也不会丢失。


13 做项目中途跟着源码一起看
仔细看源码 多查具体的知识 google或者chatgpt。
视频多看几遍就可以了 源码里记笔记。
讲义

14 悲观锁  
pessimistic lock。  
每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁。
乐观锁 
optimistic lock。  
每次去拿数据的时候都认为别人不会修改。所以不会上锁。但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，
可以使用版本号等机制。

乐观锁适合读操作多、写操作少的场景，因为这种场景下冲突的概率较低，可以减少锁的开销，提高系统的并发能力。而悲观锁更适合写操作频繁的场景，因为它可以确保数据的一致性和安全性。在实际应用中，根据具体的业务需求和并发级别选择合适的锁策略是很重要的。





图的支线
15connected component- graph


16 15-20k mq  
消息一致性问题。
基础的中高级
40万以上肯定更难。基础内容肯定要会。
http请求。  高并发的情况下。
tomcat最大线程数。
客户端，tomcat服务器端。
请求，响应。http请求。
50个线程，接收到客户端请求。
堆积请求。
线程池。不能丢失请求，装到队列里面去，堆积请求过多。
tomcat服务器端崩溃。

17 阻塞队列
使用阻塞队列的主要原因包括：

线程间协调与同步： 在多线程编程中，阻塞队列可以用于协调不同线程之间的数据交换和同步操作。当一个线程需要等待另一个线程产生数据时，它可以从阻塞队列中获取数据，如果队列为空，则该线程会被阻塞，直到队列中有数据可用。

简化编程： 阻塞队列提供了一种简单而有效的方法来处理生产者-消费者问题。生产者线程可以将数据插入队列中，而消费者线程可以从队列中获取数据。由于阻塞队列处理了线程的阻塞和唤醒操作，因此编程者可以专注于业务逻辑，而不必编写复杂的线程同步代码。

平衡系统负载： 阻塞队列可以用于平衡系统的负载。当生产者产生数据的速度快于消费者处理数据的速度时，阻塞队列可以暂时保存数据，避免数据丢失或系统资源过度消耗。反之亦然，当消费者速度快于生产者时，阻塞队列可以阻塞消费者线程，避免资源浪费。

提高系统吞吐量和性能： 使用阻塞队列可以避免线程的频繁切换和竞争条件的产生，从而提高系统的吞吐量和性能。相比于手动编写线程同步代码，阻塞队列通常能够更好地利用系统资源，提高并发性能。

总的来说，使用阻塞队列可以简化多线程编程，提高系统的可维护性和性能，并有效解决线程间的协调与同步问题。


User
就是一个加满加不进去了 一个空了取不出来了 是吗
ChatGPT
是的，您描述得很准确。阻塞队列在队列已满时会阻塞生产者线程，直到队列中有空余空间；在队列为空时会阻塞消费者线程，直到队列中有新的元素可用。这种行为确保了生产者和消费者之间的协调和同步，从而有效地处理了线程间的竞争条件和资源争夺问题。


18 单机版本mq


19 联网版本mq
kafka很复杂。运行在什么环境 什么操作系统。
手写kafka。


20 netty and nio  
什么是netty
ChatGPT
Netty是一个基于Java NIO（Non-blocking I/O，非阻塞I/O）的网络编程框架，它提供了简单易用的API，用于快速开发高性能、可扩展的网络应用程序。Netty的设计目标是提供一种简单、高效、稳定的网络编程解决方案，以满足现代网络应用程序对性能和可靠性的需求。

Netty的主要特点包括：

异步和事件驱动： Netty基于事件驱动模型，使用异步的方式处理网络操作。它通过回调、Future和Promise等机制实现了非阻塞的I/O操作，避免了线程阻塞，提高了系统的并发性能。

高性能： Netty采用了零拷贝技术和内存池管理，以及高效的事件循环机制，能够处理大量的并发连接和高负载的网络流量，从而实现了较高的性能。

简单易用： Netty提供了简洁而灵活的API，使开发者能够轻松地构建各种类型的网络应用程序。它提供了丰富的功能模块和组件，如编解码器、处理器链、事件处理器等，帮助开发者快速实现复杂的网络通信逻辑。

可扩展性： Netty的设计具有良好的可扩展性，开发者可以通过定制编解码器、处理器等组件来满足不同的需求。同时，Netty支持模块化的架构设计，使得用户能够灵活地扩展和定制框架的功能。

跨平台： Netty是基于Java NIO实现的，能够在各种平台上运行，包括Windows、Linux、macOS等，同时也支持Android平台。

总的来说，Netty是一个功能强大、性能优越、易于使用的网络编程框架，被广泛应用于构建各种类型的网络应用程序，包括Web服务器、代理服务器、游戏服务器、实时通信系统等。

User
什么是java nio
ChatGPT
Java NIO（New I/O，新I/O）是Java平台提供的一套用于非阻塞I/O操作的API和框架。它引入了一种新的I/O模型，即非阻塞I/O模型，以替代传统的阻塞I/O模型。

Java NIO 主要包含以下核心组件：

通道（Channel）： 通道是 Java NIO 中的一个重要概念，它代表了一个连接到实体（如文件、网络套接字）的开放的双向通信路径。通道提供了非阻塞的读写操作，并且可以同时支持读写操作，因此在高并发的网络编程场景中表现出色。

缓冲区（Buffer）： 缓冲区是 NIO 中用于数据存储和传输的容器。所有的数据都必须经过缓冲区进行传输。Java NIO 提供了多种类型的缓冲区，如 ByteBuffer、CharBuffer、IntBuffer 等，用于存储不同类型的数据。

选择器（Selector）： 选择器是 Java NIO 中实现多路复用的关键组件。它可以通过单个线程监控多个通道的事件，比传统的阻塞I/O模型更高效，可以极大地提高网络编程的性能和并发处理能力。

Java NIO 主要用于构建高性能、高并发的网络应用程序，例如网络服务器、代理服务器、消息中间件等。与传统的阻塞I/O模型相比，Java NIO 提供了更加灵活和高效的方式来处理I/O操作，尤其适用于需要处理大量并发连接的场景。


netty 网络编程框架
网络操作。非阻塞io操作。


21 生产者投递消息给mq服务器端，mq服务器端需要缓存该消息。
mq服务器宕机之后，消息如何保证不丢失。
手写过多线程单机mq。
1持久化机制。
消费者不在 mq的消息不会丢失。
消费者消费 mq服务器端才会删除该消息。
mq队列服务器端
生产者角色  消费者角色。
mq服务器端 将消息推送给消费者
消费者已经和mq服务器端 保持长连接。
消费者主动拉取消息。
mq如何实现抗高并发
mq异步。
延迟问题。
10万条 mq服务器端。消费者可能一条条消费。
10万条消息。先发 后发。
延迟问题。
考虑mq消费者提高速率的问题。
消费者实现集群。 批量获取消息即可。  
多个消费者。
避免消息堆积。
提高消费者速率。（mq集群）。
mq如何避免消息堆积。



22 抽象学习k8s
服务编排 容器部署化 聊聊k8s的结构 负载均衡 结构 架构体系
复杂。  难以去学习。
一个master node。多个worker node。  
部署工作节点。kubelet。
masternode里面有api server。
kubectl 指令参数和指令信息。 
scheduler. controller-manager  
etcd 分布式管理中心协调器。 etcd做整个集群状态的存储和维护。 
控制节点。  
无论是controll manager还是scheduler 下达指令给worker node。  
kubelet就是通信渠道。
pod和docker不是一对一。


23 抽象学习redis
查询一个不存在的数据（缓存穿透）
不存在 缓存穿透
不存在 缓存穿透
不存在 缓存穿透
不存在 缓存穿透

每次请求查询数据库。
空结果进行缓存。简单。消耗内存 可能会发生不一致的问题。
布隆过滤器是什么。

24 抽象学习 布隆过滤器  
根据id查询。  缓存预热是什么


25 kafka 
分布式流媒体平台。  
类似于消息队列或企业消息传递系统。
producer 发布消息的对象称之为主题生产者。
kafka topic producer  
kafka topic classification. topic  
consumer 主题消费者。  
broker 已发布的消息保存在一组服务器中 称之为kafka集群。
每个服务器都是一个代理。可以订阅多个主题。消费发布的消息。
kafka对于zookeeper是强依赖。
保存kafka相关的节点数据。


26 rabbit mq asynchronous operation
是不是只要写上了async的方法 在代码里调用 它的调用不会影响到调用之后的代码继续执行
ChatGPT
是的，一旦你在一个方法上标注了@Async注解，并且配置了相应的任务执行器（如这里使用的"taskExecutor"），那么这个方法就会异步执行。也就是说，当你在代码中调用这个方法时，调用者不会等待这个方法完成，而是立即继续执行方法调用之后的代码。

在你提供的代码片段中，sms()方法上标注了@Async("taskExecutor")，这意味着当你调用sms()时，它将在由“taskExecutor”管理的一个线程上异步执行。因此，调用sms()方法的代码不会被阻塞，它之后的代码会继续执行，不必等待sms()方法完成。这在处理需要长时间运行而又不希望阻塞当前线程的操作时非常有用，比如发送短信、执行复杂计算或者调用远程服务等。

要注意的是，使用@Async时，你还需要确保你的Spring应用上下文中配置了异步任务执行器，否则你可能会遇到NoSuchBeanDefinitionException的错误，因为Spring找不到名为"taskExecutor"的bean。

User
是不是 一个file里的文件往往用一个线程执行 但当我这样操作的时候 会为我多开一个线程操作
ChatGPT
对的，通常情况下，一个Java程序中的代码都是在一个主线程中顺序执行的。但是当你使用@Async注解时，Spring框架会为标注了这个注解的方法的执行创建一个新的线程（或者从线程池中获取一个线程），以异步的方式来执行这个方法。

在你的例子中，如果你调用了标有@Async("taskExecutor")的sms()方法，Spring会确保这个方法在一个与调用者（通常是主线程）不同的线程上执行。这就意味着sms()方法的执行不会阻塞调用它的线程。

如果你的应用中有配置一个任务执行器（TaskExecutor），那么这个执行器通常会管理一个线程池。在这个线程池中，线程会被重用，来执行多个任务，以避免频繁创建和销毁线程的开销。所以，当你调用sms()方法时，Spring会尝试使用这个线程池中的一个线程来异步执行这个方法。如果线程池中没有可用的线程，它可能会创建一个新的线程，或者等待直到有线程可用。这取决于具体的TaskExecutor配置。



27 系统稳定性  springboot异步编程对比mq
换了一个生命周期
小的生命周期
换了一个线程 

28
用户怎么知道排队结果 额外的结果 新的生命周期
用户体验提高了。实际的资源占用更大了，性能减少了。
发送mq。资源消耗是变大了。
把资源的消耗分摊到其它的节点里面。
根据压力不同 分配不同的资源。
12306抢票系统。
吞吐量和并发量比同步的高很多。


并发量。同一时间内 系统内同时处理的用户请求数。
同时处理。1s。处理完 5s。 慢一点也能处理。 那到底是1000还是5000.
跟你预期的响应时间有关。
好的电脑处理得快 并发量就大 是一个相对的数值。
响应时间。响应时间
吞吐量 给定时间内处理的业务请求数量。
qps:queries per second. 系统每秒处理的请求数量。
tps:transactions per second. 表示系统每秒钟完成的事务数量。

dns负载均衡。


29 rocketmq rabbitmq 一个java一个erlang  
kafka  
10万级 单机吞吐量。
rocketmq和kafka的可用性非常高的。
rabbitmq适合于中小型企业 可用性高。
activemq不太行。
rocketmq和kafka都是10万级。
不要用rabbitmq。  只是万级。


30 为什么需要virtual host
一个会员 一个消费的。到哪个队列进行存放消息的。
交换机。 属于分发我们的消息在哪个队列 去存放进来。  
exchange 分派我们的消息在那个队列 存放起来。
exchange。 


31 rabbitmq 控制台介绍
25672 cluster 就是集群
rabbitmq通讯端口号
amqp。 5672. 
内部通信的一个端口号。

32 简单队列 rabbitmq    
新增依赖。
kafka rabbitmq

33 消息幂等性
什么是消息队列幂等性问题
ChatGPT
消息队列的幂等性问题是指在使用消息队列进行通信时，确保即使同一消息被多次接收或处理，系统的状态和结果仍然保持不变的能力。这是分布式系统中常见的问题，因为在这些系统中可能会由于网络延迟、系统故障或其他原因导致消息重复发送或重复处理。

在处理消息队列的幂等性问题时，主要考虑以下几个方面：

消息去重：确保消息处理系统能够识别并忽略重复的消息。这通常需要在消息中包含一些唯一标识符（如消息ID或事务ID），系统根据这些标识符检查消息是否已经被处理。
操作幂等性：设计系统中的操作，使其具备幂等性。这意味着无论操作执行多少次，产生的最终效果都是相同的。例如，更新一个记录的状态、向账户添加固定金额等操作。
状态管理：在处理消息时，系统需要维护一个稳定的状态管理机制，用来跟踪每个消息的处理状态。这可以通过数据库事务、日志记录或使用状态机等方法实现。
应用逻辑设计：在设计应用逻辑时，考虑到可能的重复消息，通过合理的逻辑控制和数据校验避免错误或不一致的行为。
通过这些措施，可以大幅度减少或避免因消息重复处理引起的数据错误和逻辑冲突，提高系统的可靠性和稳定性。

User
幂等性英文是什么
ChatGPT
幂等性在英文中被称为 "idempotence"。

User
为什么叫幂等性
ChatGPT
术语“幂等性”（idempotence）源自数学领域，特别是在运算中使用。在数学中，如果某个运算对于一个元素执行多次但结果仍然不变，那么这个运算就被称为幂等的。例如，一个数乘以零的结果总是零，无论乘以多少次，或者给一个数加零也是如此。

将这个概念应用到计算机科学和信息技术中，幂等性描述的是无论一个操作进行多少次，都能得到相同的结果。在分布式系统、网络请求、数据库操作等方面，保证幂等性非常重要，因为这关系到系统的稳定性和数据的一致性。例如，在网络请求中，无论一个客户端向服务器发送多少次同样的请求，最终的系统状态和结果应当是一致的。

总之，“幂等性”一词的使用是为了描述那些结果不会因为操作的重复执行而变化的特性，这对于设计高效、可靠和预测的系统非常关键。


34 rabbitmq如何保证消息不丢失
消息确认机制 持久技术
basicConsume false 关闭mq的自动应答
手动应答
true是自动应答

35 大多数都支持持久化 持久化到硬盘。
ack 消息确认机制
异步回调 而不是同步阻塞
观察者模式 事件监听
rabbitmq：消费成功就移除
kafka：不管消费成功还是失败，该消息都不会被立即移除。
offset 知道从哪里开始继续消费。

36 dubbo框架
分布式系统相关概念

37 gateway管理网关微服务
网关是什么
ChatGPT
在计算机网络中，网关是连接不同网络的设备或程序。它可以是硬件设备，如路由器，也可以是运行网络协议的软件程序。网关的主要作用是在不同网络之间传输数据，实现数据包的转发和路由。它负责将数据从一个网络传输到另一个网络，并且通常还执行网络地址转换（NAT）、数据包过滤、安全策略等功能。网关在互联网中扮演着关键的角色，允许不同的网络之间进行通信和交换数据。


38 数据库分表
垂直分表 将一个表的字段分散到多个表中
每个表存储其中一部分字段。
优势：
1减少io争抢，减少锁表的几率 查看文章概述与详情互不影响
2发挥高频数据的操作效率。概述的操作高效率不会被操作文章详情数据的低效率所拖累。

39 优化1 把size大的字段拆分到另一个低频查询的表里面

restful api

@RestController
@RequestMapping
public ResponseEntity function(@RequeustBody param) {
    List<> articleList = apArticleMapper.load();
    return ResponseEntity.okResult(articleList);
}


分页条数的校验
校验参数 
频道参数校验
时间校验

40 流式计算
热点文章
思路说明
用户点赞行为
用户阅读行为
kafka  
发消息给stream流式处理。
stream聚合处理 kafka  
更新数据库数量


41 bootstrap servers

外键：建立和加强两个表数据之间的链接
一个表中的字段被另一个表中的字段引用
对数据造成了限制 使mysql能够保持参照完整性
维护两个表之间数据的一致性
用户表 商品表 订单表
订单表用户id和用户表构成外键
订单表商品id和商品表构成一个外键
外键一致的特性：插入订单，查询用户表和商品表，1 触发查询操作，造成额外性能消耗
2 触发内部锁 高并发死锁 3 数据一致性交给数据库处理 4 分库分表直接心态爆炸

https://www.bilibili.com/video/BV1Qs4y1v7x4?p=160&spm_id_from=pageDriver&vd_source=d4b859b0532ebb11fd37c3b6f643100f
微服务 但是三高讲的不够


























            