<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>图论专题</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        .main-title {
            color: #007BFF;
            font-size: 2em;
            text-align: center;
        }
        .content {
            margin-top: 20px;
        }
        .code-block {
            background-color: #f4f4f4;
            border-left: 3px solid #007BFF;
            padding: 10px;
            margin: 20px 0;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .link-to-other {
            display: block;
            margin-top: 20px;
            text-align: center;
            font-size: 1em;
            color: #28a745;
        }
    </style>
</head>
<body>
    <div class="content">
        <div class="link-to-other-page">
            <a href="index.html">首页/返回</a>
        </div>
        <h1 class="main-title">MapReduce</h1>
        <p></p>
        <div class="toc">
            <h2>Table of Contents</h2>
            <div class="toc-item"><a href="#section1">面试经验</a></div>
            <div class="toc-item"><a href="#section2">3月学习计划</a></div>
            <div class="toc-item"><a href="#section3">简历修改和公司调查</a></div>
            <div class="toc-item"><a href="#section4">简历和公司匹配度</a></div>
            <div class="toc-item"><a href="#section5">八股文（http）</a></div>
            
        </div>

        
        <h2></h2>
        <pre class="code-block">

        
            
        </pre>
        <div class="section" id="section1"></div>
        <p style="white-space: pre-line;">
            1. message broker1
            name server
            topic相关的所有信息。
            partition有自己对应的指针。
            producer。admin创建的topic。
            

            2 你在项目中遇到的难题
            考察经验阅历 和思路方法。不要care一味的难。
            复杂的查询手段。提炼难解决的问题。
            常见还是偏门。不要紧。互联网研发，偏门不一定难解决，常见不一定简单。
            偏门可能无关。常见而且难的。
            正常问题还是踩坑问题。

            3交易一致性问题。
            重复支付。
            超时退的问题。
            交易请求。
            用户下单 交易系统 insert交易记录。
            status = 初始。
            支付系统。
            下单支付。支付成功 异步的方式通知的。
            回调。回馈。
            有延迟。重试了怎么办。接受支付消息。每隔一段时间又发了。
            已经success，支付系统又来了，update status成功，又发货。make payment，发货两次。
            引入一个操作。分布式系统里的防重操作。
            伪代码sql语句怎么写。做一次select查询。
            select * from order_info where id = "20201020"
            java代码判断status == “初始” 执行3 否则直接返回。
            update order_info set status = "成功" where id = 20201020
            网络时差 时延

            伪防重。防重幂等。
            悲观锁的方式：begin一个transaction。
            1. select * from order_info where id = "20201020" for update.
            加record lock。一旦有第二个发送 一样for update。没有commit和rollback。
            record lock没有释放，阻塞。

            使用乐观锁。begin transaction。java代码判断status == 初始。执行3 
            否则直接返回rollback。

            2. 超时退的问题。
            商品系统回滚库存。营销系统回滚优惠券。
            商品系统。 回滚操作，分布式事务有要求。
            回滚内容。回滚失败如何解决。重复回滚如何预防。
            cap原理 consistency 一致性 客户端知道这些操作都会发生。
            分布式。可用性。每个操作都必须可以预期的响应结束。
            分区容错性。partition tolerance. 单个组件无法可用，操作依然可以完成。

            3 分布式事务。
            二阶段提交。
            异步确保型。
            事务型消息。
            raft协议。
            读写相等。

            4 mysql
            client server. 
            单点的问题 begin 开启对应的事务。 对应的执行 execute。
            commit或者rollback。
            事务提交的过程和阶段。
            client 多个server 。
            server1和server2

            transaction manager. 事务操作请求。
            交易系统的交易模型。
            营销系统。
            二阶段的方式 1和2 server 发送prepare请求。
            两次prepare 开启本地事务 对应库存的扣减可以成功的。
            事务提交到数据库里。prepare ack1 和prepare ack2发送给对应的transaction manager。 
            库存扣减。发起真正意义上的commit。commit2.
            对应的server1和2 反馈给transaction manager。 
            整个二阶段提交的事务执行成功。


            排它锁。为了consistency牺牲掉了availability。


            5 网络安全必须要的
            大厂需要安全部门
            网络状态很复杂。层出不穷的系统安全问题。
            安全事件会摧毁企业形象。安全不是伴随着java开发运作的。
            系统上线前 排期很紧张。研发 测试 上线。
            测试上线之间 安全行为检测。安全问题 安全部同事block住。
            业务指标 1月前上线。动到交互设计 上线前都是折磨。
            重新开发 重新测试。不安全的行为和接口。
            p0级别的安全事故 48小时内做的事情。
            安全设计的理念和观念。
            网络 网络安全 分布式系统 
            那安全部只要把关就可以了。
            sql注入的原理 如果drop database被注入了 就很麻烦了。对输入做校验。
            隔断符号要处理。
            输入校验。占位符拼接。mybatis里面#和$的区别。
            dollar符号和井号。两种方式。code review。sql语句都是拷贝，不会手写。
            $符号拷贝 不会用预编译的sql 而是字符串拼接。$ 严重的危机 被sql注入的风险。

            6 原栈 xss
            html页面。网站的广告位。html的信息返回给web browser client。
            获取browser内部的cookie。用户信息泄露。重大影响。反射型的xss。广告位
            js代码 很多工作的 存储型的内容去做的。
            攻击者的评论。open api 发到原栈。发布评论。
            不断跳alert。骚扰类的 alert。如果一些真正攻击类的script。document.getcookie 
            post请求 用用户的信息 往原栈post请求。伪造用户的cookie发送请求。
            攻击站。转账请求 高危。xss。用脚本语言特性 浏览器上执行 模拟用户行为。
            入口层面 输入做校验。数据都要数据库中才能拉取。关键字做拦截。script绝对不可以进入系统。
            做替换。script执行请求就没有了。
            拦截用户非法请求，没法100%。限制太死 反而拦截正常的内容。
            保护用户cookie。cookie泄露。设置cookie为http-only返回形式。script脚本语言获取用户的cookie。
            http only的访问方式 而不是脚本。

            7 csrf 跨域
            email攻击手段。
            打开攻击站b的链接。
            同样的session。打开链接的时候，攻击站b返回一个转账url。
            跨站攻击，利用浏览器同源的特性。

            8 cookie hash 
            cookie是hash出来的
            没有办法获取cookie信息的 
            没办法猜到提供给浏览器的cookie。校验。抵挡攻击行为。
            web token  这是最好的。
            还是要思路灵活。其实spam预防 ml和nlp方法也可以。
            读取到原栈a的特性。
            web token做类似策略。
            cookie方式的伪造。
            csrf 请求。
            请求体的方式。伪造用户浏览内容。加入cookie以外的拦截校验。


            9尽管有运维或者中间件。
            云模式 可视化点点点就能线上部署。但是如果是全面化人才，docker k8s 标配。
            设身处地地操作实践 侃侃而谈 做加分项目。
            部门精力 手上两个候选人 容器化部署的 经验 不需要运维人员打配合。肯定要能力更强的这个。
            云原生。不需要运维研发。
            不需要特别细节的研究。
            隔离进程。用户，网络，ipc和uts等的基础。
            隔离操作系统环境。
            namespace. 
            cgroups 控制组限制硬件资源。
            unionfs做了镜像管理。
            虚拟机的区别。
            maven repo做了镜像管理。
            部署在docker内，不需要mysql的docker，而是用镜像。
            springboot 需要java虚拟环境，只需要镜像基础上加上内容。
            springboot镜像。

            docker和应用程序没有区别 启动时间很快 秒级别一般就够了
            轻量级的。
            用户进程没区别。进程和系统的区别。

            10 java thread poll executor
            coreSize 核心线程数。
            maxSize 最大线程数。
            queueSize 等待队列数。
            keepAliveTime空闲线程多久被销毁。
            handler 拒绝策略。


            11 系统地学习各种碎片的知识。rabbitmq
            镜像队列 消息队列的可靠性和可用性。负载均衡。
            还有面试题 
            异步发送和接受。在应用程序之间传递消息的通信方式。
            应用解耦。
            订单系统。库存系统。
            物流系统。
            通知库存系统。
            引入mq之后，mq会负责分别发送给库存和物流系统。
            服务挂掉了，整个系统下单失败。解耦。
            写入mq就可以下单成功，不管库存系统好了没。
            提高系统的容错。fault tolerant。
            从注册到响应 有延迟。500ms到320ms 邮件通知和短信通知。
            mq异步 邮件通知和短信通知。

            秒杀场景下。 每秒1w请求。订单服务每秒处理1k请求。
            引入mq以后。mq 每次拉取1k请求，慢慢处理。每秒处理1k请求。分批 不同的batch。

            降低可用性 外部依赖多了。
            复杂度高了。保证消息没有被重复。
            数据不一致。

            12 amqp协议
            交换机 多个队列 load这些消息。
            队列存储消息 说白了就是处理顺序决定了数据结构而已。


            13 jpa
            在Spring Boot项目中，虽然数据库已经存在，但你仍需要定义实体类来表示数据库表中的行，因为这是Java程序与数据库进行交互的方式。

实体类是使用Java Persistence API（JPA）定义的，它是一种ORM（对象关系映射）规范，允许你使用面向对象的方式来操作数据库。@Entity和@Table注解告诉Spring框架这个类应该被当作一个实体来处理，并且与一个特定的数据库表映射。@Id注解用于指定类的属性映射到表的主键。

通过这种映射，你可以在Java代码中操作这些实体对象，而不是直接使用SQL查询。这使得代码更容易理解和维护，同时也减少了直接处理SQL查询时可能出现的错误。

以下是为什么在Spring Boot项目中需要这些实体类的主要原因：

抽象: 实体类提供了数据库表的高级抽象，允许开发者使用面向对象的方法来操作数据。

简化数据访问: 使用Spring Data JPA等框架可以极大简化数据库操作，如增删查改等。

类型安全: 编译时的类型检查减少了运行时错误的可能性。

自动化: 许多数据库操作可以自动化，如自动生成查询。

解耦: 代码和数据库逻辑的解耦有利于维护和测试。

因此，即便数据库已经存在，这些实体类是连接数据库与Java应用程序的重要桥梁。
ORM: object relational mapping


14 编写代码来进行测试有几个重要原因，即使可以通过人工方式测试应用程序：

自动化：编写测试代码允许自动化测试过程。这意味着测试可以快速且一致地重复执行，而不需要人工干预。每次代码变更后，都可以自动运行测试来确保变更没有引入任何问题。

可靠性和准确性：人工测试可能会因疏忽或误解而导致错误。自动化测试每次都会以相同的方式执行，减少了由于人为因素造成的错误。

时间和成本效益：虽然初期编写测试代码可能需要时间和精力，但长期来看，自动化测试可以节省大量的时间。一旦编写，就可以在不增加额外成本的情况下多次执行这些测试。

文档作用：测试代码也可以作为项目的活文档。通过阅读测试，可以理解代码的预期行为和使用方式。

持续集成/持续部署（CI/CD）：自动化测试是CI/CD实践的基石。在CI/CD管道中，每次代码提交都会触发自动化构建和测试过程，确保新代码集成后应用程序仍然稳定。

早期问题发现：通过编写测试，可以在代码部署到生产环境之前发现问题。这种“预防胜于治疗”的方法可以避免未来的用户遇到这些问题，提高用户满意度。

回归测试：在软件开发过程中，新增功能或修复bug可能会导致旧代码出现问题。自动化测试可以确保现有功能在新变更引入后继续正常工作。

优化性能：性能测试通常很难通过手动测试完成，特别是需要模拟多用户或高负载情况时。自动化测试可以在不同的性能级别上执行，以确保应用程序表现良好。

jmeter性能测试 这个很有用的。

15 document object model 
web page. 
document object represents your web page

16 可用性 一致性
主节点 从节点。
服务集群。
服务集群3个 。 
岁月静好的图片。
集群之间的调用访问失败。
不能保证一致性 有致命后果。
可用性也很重要。
当网络分区发生时：

如果系统保证一致性，那么它可能需要在分区的不同部分之间停止操作，直到一致性能够再次被保证。在这个过程中，系统可能无法对外提供服务，违反了可用性的原则。
如果系统保证可用性，即使在网络分区的情况下，系统仍然需要对外提供服务。这可能会导致在不同分区上的数据副本之间出现不一致的状态，因为某些更新可能还没有被所有分区看到。
因此，在分布式系统中，当网络分区发生时，一致性和可用性不能同时成立。系统设计者需要根据具体的应用场景和需求权衡这两个属性。例如，一个银行系统可能更偏好一致性，以确保所有的账户余额随时准确无误；而一个社交网络可能更偏好可用性，允许用户在网络分区时仍能发布和查看消息，即使一些更新可能会延迟同步。


比如银行余额很要求一致性。
社交媒体需要可用性。
新的leader节点。
版本更老的leader退居二线。
曾经的 回滚。 leader变成follower。raft算法全貌。
所有节点都是受信节点。
脑裂和lease。


17 不同集群数据不一样。
不同的领导 大导 脑裂的问题。
全局过半的解决方案。
5台服务器的过半 大于等于3的选票 当选leader。
zookeeper解决脑裂 的方案。
集群的机器通信。自己投自己。
三台机器。


18 springboot service and controller
在软件架构中，特别是在遵循分层架构的应用程序中，将Controller和Service分开设计是为了关注点分离（Separation of Concerns, SoC）和单一职责原则（Single Responsibility Principle, SRP）。这样做有几个好处：

分层清晰：每层负责不同的任务。Controller层主要负责处理HTTP请求，验证输入，返回响应等。而Service层负责业务逻辑，它执行具体的操作，如数据处理和计算。

重用性：Service层可以被应用中的多个Controller重用。这意味着相同的业务逻辑不需要在不同的Controller中重复编写。

测试容易：分层架构允许独立测试每一层。例如，可以单独对Service层编写单元测试，而不需要关心HTTP请求的处理。

灵活性和可维护性：如果需要更改业务逻辑，只需要更改Service层的代码。同样，如果更改请求处理方式或引入新的请求类型，通常只影响Controller层。

减少代码耦合：控制器和服务之间通过定义清晰的接口进行通信，这有助于减少代码间的耦合度。

易于管理事务：业务逻辑层（Service层）是处理应用程序事务的理想位置，可以在这一层处理诸如数据库事务之类的操作。

在Spring Framework中，这种模式特别普遍，因为它符合Spring的设计哲学，Spring推荐的是一个轻量级的Controller层和一个充满业务逻辑的Service

比如补货员和顾客都要看是否商品库存足够 走要用这个service。而且下订单也需要用这个service。


19 high cohesion 
高内聚（High Cohesion）是软件开发中的一个设计原则，它推荐在一个模块或者一个类中应该只包含那些彼此紧密相关的功能。内聚是度量一个模块内部各个元素之间功能相关性强度的指标。高内聚通常意味着：

单一职责：每个模块或类都应该只有一个改变的理由，即只负责一件事情。
易于理解：因为模块只做一类事情，所以更加直观易懂。
易于维护：相关的功能聚集在一起，当改动一个功能时，不太可能影响到其他不相关的功能。
增强模块的可复用性：因为模块聚焦于一件事，它可以在不同的上下文中重用，而不需要包含不必要的功能。
例如，如果你有一个OrderService，它应该包含所有和订单处理相关的行为，如创建订单、计算订单总价、验证订单状态等。这样，OrderService就是高内聚的，因为它包含的所有功能都直接与订单处理相关。相对的，如果OrderService还包含了用户认证或者处理支付的逻辑，那它就是低内聚的，因为这些功能应该被分配到其他专门的服务中，例如AuthService或PaymentService。

在实践中，高内聚通常与另一个原则——低耦合（Low Coupling）——一起使用。低耦合意味着各个模块之间的依赖关系最小化，每个模块相对独立。高内聚与低耦合共同构成了可维护和可扩展软件设计的基石。

20 data transfer object 

为什么需要传输dto而不是data entity objects
ChatGPT
传输数据对象（Data Transfer Objects，简称DTO）而不是直接使用数据实体（Entity Objects）在多层应用程序中是一个常见的做法，主要原因包括：

安全性: 数据实体可能包含敏感信息，例如用户密码或支付信息，不应该直接暴露给客户端。使用DTO，可以确保只有那些确实需要被客户端看到或处理的数据才会被传输。

隐藏实现细节: 实体对象通常与数据库的表结构紧密相连，直接暴露这些对象会泄露数据库的内部结构。DTO允许你自定义暴露的数据结构，从而避免暴露数据库模型和业务逻辑。

解耦: 数据实体的改变往往直接影响数据库，如果直接传输实体，任何客户端代码的变动都可能导致服务端的变化，使用DTO可以减少这种耦合。

网络开销: 实体对象可能包括大量客户端不需要的数据。使用DTO可以构造更加精简的数据对象，仅包含所需信息，减少网络传输的负载。

灵活性: 在某些情况下，显示给用户的数据可能是多个实体对象的组合。DTO可以将这些数据整合在一个对象中，而无需创建复杂的对象关系。

API稳定性: 如果使用实体对象作为API的一部分，那么任何对实体结构的更改都可能破坏API的兼容性。使用DTO可以避免这种情况，即使底层的实体发生了变化，只要DTO保持不变，API就不会被破坏。

交叉关注点: 数据实体可能包含业务逻辑或与特定的持久化机制相关的注解，这些通常与数据传输无关。DTO则专注于数据传输的需求，排除了与其无关的业务逻辑和持久化逻辑。

数据格式化: 在向客户端发送数据之前，你可能需要对数据进行特定格式化（例如日期时间格式），DTO允许你在不影响实体对象的情况下做这样的转换。

因此，使用DTOs作为应用程序各层之间数据交换的媒介是为了增加安全性、灵活性和解耦，同时保持API的稳定性，并减少网络负担。



21 repo dao
#这里的findbyemail方法为什么没有定义 spring jpa帮忙弄好了是吗
ChatGPT
是的，你的理解是正确的。在你提供的CustomerRepository接口中，findByEmail方法以及其他的findBy*方法没有具体的实现代码，这是因为Spring Data JPA提供了一种方法自动实现的机制。

Spring Data JPA允许你通过简单地声明方法签名来定义对数据库的查询。框架会根据方法名的约定来自动生成查询的实现。比如，在你的CustomerRepository接口中，findByEmail方法的预期行为是根据电子邮件地址查找一个CustomerEntity实例。Spring Data JPA会解析方法名，并根据findBy后面的部分（这里是Email）来确定查询的条件。因此，它会生成一个类似于SELECT * FROM customer_entity WHERE email = ?的SQL查询。

这种方法的好处是，它简化了DAO层的代码编写工作，因为开发者不需要为常规的CRUD操作手动编写SQL语句或实现方法。此外，它还减少了出错的可能性，因为大部分的查询逻辑都是由框架自动生成的。

Spring Data JPA支持的查询方法名非常灵活，可以包括多种条件表达式，如And、Or、Between、LessThan、GreaterThan等。如果需要更复杂的查询，你还可以使用@Query注解直接指定SQL或JPQL语句，就像updateNameById方法那样。

简而言之，Spring Data JPA通过解析方法名或@Query注解中定义的查询来自动实现这些接口方法，大大简化了数据访问层的代码量，提高了开发效率。

User
这个文件就属于dao层的代码是吗
ChatGPT
是的，这个文件属于DAO层的代码。在使用Spring Data JPA时，通常会使用术语“repository”来代表数据访问层（DAO层）。CustomerRepository接口是一个数据访问对象（DAO），它定义了如何访问CustomerEntity数据。

Spring Data JPA中的repository提供了一种更加简洁和声明式的方式来定义数据访问操作。通过扩展Spring Data提供的接口（如CrudRepository、PagingAndSortingRepository或JpaRepository），你可以获得许多常用的数据访问方法，无需手动实现。此外，你还可以根据需要，通过简单声明方法签名来定义自定义查询。

在你的例子中，CustomerRepository通过扩展ListCrudRepository（这可能是一个打字错误或自定义的接口，标准的Spring Data JPA通常使用CrudRepository或JpaRepository）来定义针对CustomerEntity的数据访问操作。这个接口就充当了传统意义上的DAO角色，封装了所有与CustomerEntity相关的数据库交互逻辑。

因此，在Spring Data JPA的上下文中，虽然术语可能有所不同，repository实质上执行的是DAO层的职责。

repo实际上就是dao 术语的不同。


22 Hibernate
Hibernate是一个开源的Java持久化框架，它提供了一个ORM（Object-Relational Mapping，对象关系映射）的实现。它的目的是解决Java对象（实体）和数据库表之间的映射问题，使开发者可以更加自然地使用面向对象的方式来操作数据库。Hibernate不仅作为JPA（Java Persistence API）的一个实现，而且还提供了一些超出JPA标准的特性。

Hibernate的主要特点和功能包括：

数据持久化：Hibernate允许将POJO（Plain Old Java Object）映射到数据库表中。这意味着你可以将数据库中的行看作是Java对象，并且可以在Java代码中操作这些对象，而Hibernate会负责将这些操作转换成对应的数据库操作。

查询能力：Hibernate提供了强大的查询能力，包括HQL（Hibernate Query Language），这是一种面向对象的查询语言，以及Criteria API，用于以编程方式构建查询。Hibernate 5.2及更高版本还支持JPA Criteria API。

缓存：Hibernate具有第一级缓存（Session缓存）和第二级缓存（SessionFactory缓存），可以有效减少数据库访问次数，提高应用性能。

事务管理：Hibernate提供了对JTA（Java Transaction API）和非JTA事务的支持，允许开发者在应用程序中灵活管理事务。

自动表生成：Hibernate可以根据实体类自动创建或更新数据库表，这使得数据库设计与应用程序开发可以更加紧密地集成。

方言支持：Hibernate支持多种数据库方言，这意味着你可以在不同的数据库之间切换，而不需要修改代码。

Hibernate与JPA的关系：

JPA是Java持久化领域的标准规范，Hibernate是这个规范的一个实现。这意味着你可以使用JPA的API来编写代码，而底层实现则可以是Hibernate或其他JPA提供者（如EclipseLink或OpenJPA）。

使用Hibernate作为JPA提供者可以让开发者享受到Hibernate特有的一些高级特性，同时还能保持与JPA标准的兼容性，使得在不同的JPA实现之间迁移变得更加容易。

总的来说，Hibernate作为一个成熟且广泛使用的ORM框架，为Java应用与数据库间的交互提供了一个高效、抽象的层，大大简化了数据持久化的工作。

            
23 jpa and Hibernate
从你提供的代码片段来看，这里实际上使用的是Spring Data JPA，而不是直接使用Hibernate。不过，Spring Data JPA底层默认是通过Hibernate这个JPA提供者来实现数据访问的，所以间接地，你的项目可能是基于Hibernate的。


24 email server
我明白您的担忧了，关于收到大量邮件导致SMTP服务器负载过大的问题，确实，这种情况更多地涉及到邮件接收（即IMAP/POP3服务器）而非发送（SMTP服务器）。如果您担心的是因为收件量过大而导致的问题，那么应对策略会有所不同。对于这种情况，可以考虑以下几种解决方法：

邮件服务器的负载均衡：通过设置邮件服务器集群并实施负载均衡策略，可以分散邮件接收的压力。这涉及到在多个服务器之间分配邮件流量，以防单一服务器因过载而出现性能问题或宕机。

增强邮件服务器的资源：确保您的邮件服务器拥有足够的处理能力和存储空间来处理高邮件量。这可能意味着升级服务器硬件或扩展云服务资源。

实施反垃圾邮件措施：使用反垃圾邮件解决方案可以减少垃圾邮件的数量，从而降低服务器的负载。这些措施可能包括设置SPF（发件人策略框架）、DKIM（域名密钥识别邮件标准）和DMARC（域名基础邮件身份验证报告和合规性）记录，以验证发件人身份，并使用第三方反垃圾邮件服务。

设置邮件过滤规则：在邮件服务器上设置过滤规则，可以在邮件到达用户邮箱之前过滤掉垃圾邮件或不必要的邮件。这可以通过关键词过滤、发件人黑名单或其他标准实现。

监控和管理：定期监控邮件流量和服务器性能，可以帮助您及时发现并解决问题。使用专门的监控工具来跟踪邮件量、服务器负载、存储使用情况等，以及在检测到异常时发送警报。


25 日志记录

在软件开发中，日志记录是一个关键的方面，它帮助开发者了解应用程序的运行状态、诊断问题以及进行性能监控。logger.info()和System.out.println()都可以用于输出信息，但它们各自的用途和功能有显著差异：

logger.info()
可配置性：日志记录器（如Logback、Log4j）提供了高度的可配置性，允许开发者控制日志信息的格式、级别和目标输出地点（如控制台、文件、网络等）。

性能：相比System.out.println()，使用日志记录器在性能上通常更优，尤其是当日志级别排除了大量日志条目时（例如，只记录错误而忽略调试信息）。

日志级别：日志记录器支持不同的日志级别（如DEBUG、INFO、WARN、ERROR），这使得管理日志和筛选重要信息变得容易。

线程安全：日志记录器设计为线程安全的，适合在多线程环境中使用。

集成与分析工具：日志数据可以被各种工具用于监控和分析，这在生产环境中特别有价值。

System.out.println()
简单性：直接向标准输出流（通常是控制台）打印消息，易于使用，对于快速的调试或小型脚本可能足够。

性能开销：对于高频率调用，System.out.println()可能会引起性能问题，因为它在打印每条消息时都会竞争同步锁。

缺乏灵活性：无法调整输出级别、格式或目标，所有消息都以相同的方式处理。

不适合生产环境：在生产环境中使用System.out.println()进行日志记录通常不是一个好选择，因为它不支持日志级别控制，也不易于集中管理和分析。

结论
因此，尽管System.out.println()在某些场景下（如简单脚本或快速调试）可能足够使用，但在生产级应用程序中，logger.info()（或其他日志级别方法）是更好的选择，因为它提供了更大的灵活性、更好的性能和更高级的功能，如日志级别管理、格式化和集中日志管理。这些特性使得logger.info()更适合进行细粒度的日志记录和生产环境的日志管理。

26 Producer 
创建链接工厂
new一个connectionfactory
第二部 配置服务地址
主机host
ip  
账号 
username 
admin的账号 设置密码 
创建交换机 交换机名称
交换机类型 
fanout headers
direct topic  


队列名称 
队列是否需要持久化
但是要注意 这里的持久化 是队列名称 
等这些元数据的持久化 不是队列中消息的持久化 
第三个参数 表示队列是不是私有化的 
如果是私有的 创建他的应用程序才能消费消息。 
false 不是私有的 。 队列在没有消费者订阅情况下 
是否自动删除。 队列的一些结构化信息。 
生命死信队列。 磁盘队列会用到。 


27 session和cookie 
把 cookie 视为 "小 session" 是一种简化的比喻，但不完全准确。它们都是用于跟踪用户状态和身份的，但在用途和工作机制上有明显的差别。理解它们之间的区别可以帮助我们更准确地描述它们的功能。

Cookie:
是客户端的存储机制，用于保存用户数据。
可以存储诸如用户偏好、会话标识符等小型数据片段。
容量较小（例如，每个域名下浏览器通常限制为50个cookie，每个cookie最多4KB）。
可以由服务器或客户端脚本设置，并由浏览器存储和管理。
对于每个相关域的请求，浏览器都会自动将cookie发送给服务器。
Session:
是服务器端的存储机制，用于保持用户状态。
可以存储大量数据，比如用户认证、购物车内容、用户请求的上下文等。
存储容量通常只受服务器资源和配置的限制。
通常由服务器创建和管理，用户无法直接访问。
通常依靠一个唯一的会话ID来识别用户，这个ID可以存储在cookie中来维持会话状态。
如果要比较，可以认为 Cookie 和 Session 是配合使用的：cookie中通常会存储一个指向服务器上session的引用（即会话ID），而实际的用户数据是存储在Session中。这样，Cookie可以看作是会话的“钥匙”，而Session则是存放“内容”的保险箱。

而关于DTO（Data Transfer Object）和数据实体对象（Entity Objects），这个比喻其实是合理的。DTO是简化的对象，通常用于服务层和表示层之间的数据传输，它可能只包含实体对象的一个子集，用于特定的操作或视图。所以在这个上下文中，DTO确实可以被视为“小的”或“部分的”实体对象。

User
所以cookie是指向session的指针
ChatGPT
对，你可以把 cookie 中存储的会话 ID 看作是指向服务器上 session 的指针。在这种情况下，cookie 本身并不存储用户的会话数据，而是存储一个唯一标识符，服务器利用这个标识符来找到对应的 session，并获取或修改其中的数据。

这是一个常见的模式，用于维护状态和用户会话跟踪，因为它结合了 cookie 和 session 的优点：cookie 提供了一种机制，使得无状态的 HTTP 请求可以被关联到一个状态，而 session 则在服务器端安全地保存了用户数据。通过这种方式，即便是跨越多个请求的用户交互，服务器也能够“记住”用户的状态。

28 cookie和session的实际应用场景 用户访问网站：

用户打开浏览器并访问你的网站。
服务器生成一个唯一的 session ID，并将其作为 session cookie 发送到用户的浏览器。
用户登录：

用户点击登录并提交用户名和密码。
服务器验证凭据，确认登录。
登录成功后，服务器可能会更新该用户的 session 数据，包括用户身份信息和登录状态。
浏览和添加产品到购物车：

用户浏览商品并点击“添加到购物车”。
服务器接收到带有 session ID 的请求。
服务器检索与 session ID 关联的 session 数据，这个 session 包含了用户的购物车信息。
服务器更新 session 数据，添加新的商品到购物车中。
持续的交互：

用户继续浏览，并可能添加更多商品到购物车。
对于用户发起的每一个请求，浏览器都会自动发送包含 session ID 的 cookie。
服务器利用这个 ID 来识别用户并提供个性化的内容，如购物车中的商品列表。
结账和退出：

用户准备结账，点击“结账”按钮。
服务器利用 session ID 来处理结账流程，包括订单创建和支付处理。
结账完成后，用户选择退出。
服务器结束用户的 session，并且清除或更新 cookie，移除或改变 session ID。
在整个过程中，session cookie 是关键，因为它确保了服务器能够为用户提供连续和一致的体验，即使是在无状态的 HTTP 协议上。同时，由于实际的用户数据（如购物车内容和用户个人信息）存储在服务器上，因此提供了更高的安全性。


这个是不是类似于 比如我去一家咖啡店 店员记住我了 并且记得我每次点焦糖玛奇朵和蛋糕 下次来的时候直接问我是不是要这个商品 而且还记得我喜欢坐的位置 给我预定好
ChatGPT
是的，这是一个很好的比喻！想象一下，在现实生活中的咖啡店：

Cookie： 当你进入咖啡店时，店员给你一个号码牌，这个号码牌唯一地标识着你。这相当于网站给你的浏览器一个包含 session ID 的 cookie。这个号码牌（或 session ID）本身不包含其他信息，但它是店员用来识别你的方式。

Session： 店员（服务器）使用这个号码牌（session ID）去查看一个记录本（服务器上的 session 存储），找到与你相关的所有信息。这包括你通常点的焦糖玛奇朵和蛋糕，以及你喜欢的座位。所有这些信息都是店员（服务器）保留的，不会告诉其他顾客（客户端），保证了信息的私密性。

每次你进入咖啡店（发送请求到服务器），你只需展示你的号码牌（浏览器发送 cookie），店员就能查到所有关于你的信息，并提供个性化服务（个性化网页内容）。如果你告诉店员下次不再来了（注销），他们就会撕掉你的号码牌（删除 session），这样你下次来的时候就会像一个全新的客人一样开始新的互动（新的 session）。

这样，咖啡店通过号码牌和记录本保持了对客人偏好的记忆，就像网站通过 cookie 和 session 来跟踪用户的偏好和状态。

29
caching. cache hit. 
cache miss. 
application -> cache -> data -> cache -> application
application -> cache -> application  


800ms 引入缓存提高系统性能
第一个用户进来 同样的流程
引入了redis
双写不一致 缓存的问题
数据不一致的问题
穿透雪崩
高并发。
redis宕机 
mysql。承接流量太大。
也可能会出现大量请求。
key的并发量扛的很多。


30 进程之间的协作
共享存储 
消息传递 message passing
消息缓冲队列。
双方进程的id


31 物理服务器部署优缺点
physical server。 operating System 
application。 安装单独的操作系统。 
成本高 部署慢。资源浪费。难于迁移和扩展。
可能会被限定硬件厂商。

一个物理机部署多个app。
vmware安装多个操作系统。
每个app独立运行在一个vm里。
alibaba cloud云服务器。
rds服务器。搭建了数据库服务。
不需要自己购买机器 不需要自己的物理服务器 阿里云帮忙维护。
硬件服务器 虚拟化手段。用的是人家的虚拟机。
虚拟化 就是资源管理技术。
组合出电脑环境配置。
vmware 翻译 模拟 交给宿主机 真实的物理机本体。vmware是个翻译官。


32 人为操作 该配置 改操作
沟通成本很大。
改配置很容易改错。
测试环境。
开发环境。 
部署环境。
代码和一堆依赖关系 环境依赖 打包为镜像文件。
其它程序直接运行 不需要各种询问 配置。 
手动配置很容易出错。

33 docker  
10个虚拟机 可以启动100+个容器
docker run只需要1s
kvm虚拟机需要20s
cpu虚拟化支持 容器不需要cpu虚拟化支持

docker的镜像 部署 迁移 还可以跨越系统平台。
google 04年开始用容器技术。
所有的应用都运行在容器中。每周启动20亿个容器。
每秒钟要启动超过3000个容器。
不包括长期运行的容器。
google在将容器集成到google云平台中。
2014推出了开源容器集群管理系统，Kubernetes。
Kubernetes构建在Docker之上。


34 cache evict的使用场景
什么时候用cacheevict ，update delete和add都用吗
ChatGPT
使用 @CacheEvict 的决策主要基于对缓存数据一致性和应用程序性能之间的权衡。这个注解用于从缓存中移除条目，因此它在维护缓存数据新鲜度方面起着关键作用。下面是几种常见的使用场景：

删除操作（Delete）: 这是 @CacheEvict 最直接的应用场景。当你从数据库或你的持久层中删除一个对象时，相应的，你也会希望从缓存中移除这个对象的条目，以避免脏读。

更新操作（Update）: 在更新操作中使用 @CacheEvict 也是非常普遍的。当一个对象被更新时，缓存中存储的旧版本就不再准确，需要被移除或更新。这里你有两个选择：

使用 @CacheEvict 来移除旧的缓存条目，这样下次访问时就会从数据库中重新加载最新的数据并更新缓存。
使用 @CachePut 来同时更新数据库和缓存中的数据，这样可以确保缓存中的数据总是最新的。
添加操作（Add）: 对于添加操作，通常不需要使用 @CacheEvict，因为添加操作不会使得已缓存的数据过时。然而，在某些情况下，如果添加操作会影响到基于特定查询结果的缓存，例如列表或集合的缓存，那么可能需要使用 @CacheEvict 来清除这些特定的缓存条目，以确保下一次查询能够返回包含最新添加的数据的结果。

决策指南：

使用 @CacheEvict：当你的操作会使得已缓存的数据过时或不再准确时，比如删除和更新操作。
慎用或不用：如果你的操作是添加新条目，并且这个新增不会影响到已缓存的查询结果的准确性，那么通常不需要使用 @CacheEvict。
总之，正确使用 @CacheEvict 可以帮助维护缓存数据的一致性，但同时也需要注意不要过度清除缓存，以免影响应用程序的性能。







            健身： 3.14 容量 胸部7000kg 背部和二头2500kg 蛋白奶昔一瓶

几个建议行动：
1 力扣多刷medium和easy 主要积累巧妙解法
2 sql刷掉
3 练习java和C#写api 这个得多做项目了
4 做一份公司调查 看看每个公司用什么技术栈和项目
</p>
<p style="white-space: pre-line;">

如果把求职季度 这么做比喻 
2月初 摸底考试
3月 月考
4月 期中考 
5月 月考 5月中 期末考

我现在3月 刚面试了here technologies和特斯拉 无论月考成绩如何 我来不及为月考多想 接下来即将迎来挑战的是期中考试！我要奋战百天 期末考试倒计时百天 

我不想苟且在现在的小公司 我要去大公司 我一定要去能让我毕业后return的大公司 每一天我都会活得无比认真

3月
学习计划 1在力扣已经做的400多题里选出100来道精华的medium 无意义的hard题不纠结。把这100题刷烂。
2 做一个移动端项目 做一个nft项目/再做一个infra项目
3 把bq面试的一套视频课程看完。
4 同步投递国内岗位 投至少100份吧 美国上个月投了300份 这个月再投300份
5 sql习题做30道
6 熟练反复写50个api (java C#)
        </p>
        
        <p style="white-space: pre-line;">
          # MapReduce
            使用代码统计 20GB文件 
            可能要统计13分钟 gb级别很久 。pb tb 那就更恐怖了。
            gfs mapReduce bigTable（03-06年）
            mapReduce 大任务 拆分到小任务 divide and conquer.
            
            让家长爸妈弟弟帮忙写作业。作业撕碎给三个人 map是作业撕碎。 reduce就是作业组装。
            map shuffle分区排序。合并排序。reduce处理并且出来结果。
            生成多个map任务
            根据数据量大小 生成map任务 kv键值对。根据key计算所属分区 去到哪一个reduce。
            
            
            面试经验多了会形成综合性的结论。有些新奇的 综合性大的认知会在脑子里形成。
            比如结合tesla和here的面试，了解到需要“针对流”投简历。
            
        </p>

            <div class="section" id="section3">简历修改和公司调查</div>
        <p style="white-space: pre-line;">
            我不懂甚至不怎么听说的技术栈：RDBMS（貌似是database management system 但是不知道r是什么
            Kubernetes不懂（DE方向）遇到三次 两次是sde方向
            Robotics不太会
            Go不太会
            Helm不太会 
            Cypress不太会
            Agile 遇到两次（tesla和caci等）
            elastic（2次）
            low-level OS internals in Windows
            windows OS kernel
            system design, architecture
            测试：jest，nunit，playwright，cypress，
            部署：docker，kubernetes，jenkins
            开发方式理念：agile

            nvidia: hardware architecture.
            performance analysis
            embedded accelerators- automotive or robotics
            computer graphics: accelerated rendering apis: opengl, vulkan, directX
            autonomous driving, infotainment
            C++
            real time rendering algo
            ray tracing,
            gpu graphics pipeline
            gpu architecture
            compute programming apis
            multi-threaded programming techniques
            cuda parallel programming
            gpu development, chip design
            GPU apis, unix/ shell scripting
            ElasticSearch
            spark, elk, cassandra, kafka, angular
            high performance computing
            graphics apis(做一个项目)
            reproduce一个compiler相关的论文
            Amazon: distributed systems, linear programming

            3月 spotify 4月nft around 5月 systems architecture 6月 graphics 7月 elastic search kafka 
            8月 巩固system design 分布式系统 操作系统

            返璞归真：还是把前后端学扎实 还有系统设计 刷题。剩下的学有余力再去弄。有的放矢。
            https://www.1point3acres.com/bbs/thread-795715-2-1.html
            jobscan多用一下

        </p>

        <div class="section" id="section4">简历和公司匹配度</div>

        <p style="white-space: pre-line;">
            tesla: 39%
            spotify: 38%
            
              
          </p>

        <div class="section" id="section5">八股文，ood，system design</div>
        <p style="white-space: pre-line;">https://juejin.cn/post/7139706559092752414
            如果多做几个项目 对于写api，对于http get post delete put以及几个状态码就应该非常熟悉。
            对于database的sql也应该做到非常熟悉才对。

            https://www.youtube.com/watch?v=CsWFuFdlBVU
            学习ood
1 system design(design twitter)
            Suppose you work as an engineer at a well-known company providing social services. Your task is to improve real-time event processing to get frequent results. Which tool below will help you the most in this scenario?

           Apache Kafka is a framework for distributed real-time event processing and storage. 
           2.Assume that an account of a public figure with millions of followers posts a Tweet on Twitter. Your system will need to handle millions of interactions with this Tweet by the account’s millions of followers. Which solution below is the best way to handle this traffic, assuming that the system knows the audience details of the Tweet?
           increase or dedicate some servers to particular locations where a large portion of the audience belongs. 

           design twitter: storage, bandwidth, computational resources
           api design
           3 怎么design一个twitter
           第一 我们要去思考一些functional requirements/ non-functional requirements
           post tweets: post one or more
           delete, like, reply, search, follow, view User
           non-functional: low latency. scalability of computational resources
           4 什么是CDN
           content delivery network
           5 什么是load balancer
           performance.
           adding servers. scalability
           availability
           6 REST API复习
           的，REST API通常非常适合Web应用程序（Web apps）开发，原因如下：

简单性：REST利用了HTTP协议的现有特性，如HTTP方法（GET、POST、PUT、DELETE等）来对资源进行操作。这使得REST API相对简单易懂，并且易于实现。

无状态性：REST是无状态的，这意味着每个请求都应包含执行请求所需的所有信息，而不依赖于之前的请求。这种特性使得REST服务更容易扩展，并且更适合Web环境，其中客户端与服务器之间的交互可能非常频繁且独立。

可缓存性：RESTful服务的响应可以被明确地标记为可缓存或不可缓存，这有助于提高应用程序的性能和效率，通过减少对服务器的直接请求。

统一接口：REST的统一接口约束使得与API的交互更加一致和标准化，这有助于开发者更快地理解和使用API，同时也便于API的维护和更新。

灵活性：由于REST基于标准的HTTP协议，它可以使用任何可以发送HTTP请求的客户端进行交云。这使得创建多平台应用程序（如Web、移动和桌面应用程序）变得更加容易，因为它们都可以通过REST API与后端服务进行交互。

可伸缩性：REST API的无状态性和可缓存性使其在处理大量并发请求时表现良好，这对于构建大规模Web应用程序是非常重要的。
7 search tweet api
searchTweet(user_id, search_term, max_result, exlude, media_field, expansions, sort_order, next_token, user_location)
8 reply to tweet
replyTweet(user_id, tweet_id, tweeted_user_id, reply_type, reply_content, reply_length)


        </p>
        <div class="section" id="section5">mock interview的bq</div>
        <p style="white-space: pre-line;">
            要说自己是fullstack程序员 突出springboot java。
突出restapi的经验。

介绍公司。组织体育比赛。event system。
create the event system。没有context。
简历可以写短一点
做的东西有点空。
code base里面看别人写的怎么样。

要有一个比较困难的东西讲故事。
在hiring manager那边只会得到相同的判断。
一般都是面试senior engineer。不认得你 给出的判断是这样的。
别的项目比较完整的功能套过来。
看看code base 看看notification system有哪些东西，逻辑了解得更加透彻一点。
增加整个功能的长度。
包括你自己做这个template 你会怎么做。
mvc framework和springboot有什么不一样。
intentional的问题。
答案并不好，spring mvc也是一个mvc的framework。
大部分情况下 也要develop mvc的
jpa的功能。
java persistence api.
还可以用hibernate。
就会question你的整个简历的真实性。也许会save time。个人没有.NET的真实性。
mvc没有答出来 就不行 花过十几个小时。
简历还需要再去 写下来 看看。
写下来之后花多长时间。
算法 4个方面：1 communication 2 code quality 3 verification 4 clarification
这四条来考察。
碰到难点了 去沟通。problem-solving。最终的结果 验证的时候有没有发现问题
做的比较好的是你的communication。还不错的。
但是中间有个地方，有些面试官 你写错了 不会管的。
brute force太容易想了。但凡一线公司不会让你用这个算法过。
o n square。
用一些sorting algorithm是可以接受的。 free giveaway。 如果同意的话。
brute force is a give away.
sorting algorithm.
你的项目很水是会被发现的。
第二个hashmap 看看哪个被看过了。
算法不够灵活。sorting algorithm。
128题
nlogn可以。
最后的communication要好好弄。

提高的就是


        </p>
  
              
    </div>
</body>
</html>
