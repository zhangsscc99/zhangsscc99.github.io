<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>以雷霆击碎SpringBoot</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: left;
            margin-top: 50px;
        }
        .main-title {
            color: #007BFF;
            font-size: 2em;
        }
        .description {
            margin-top: 20px;
            font-size: 1.2em;
        }
        .tips {
            margin-top: 40px;
            color: #28a745;
            font-size: 1em;
        }
    </style>
</head>
<body>
    <div class="content">
        <div class="link-to-other-page">
            <a href="index.html">首页/返回</a>
        </div>
        <h1 class="main-title">以雷霆击碎SpringBoot</h1>
        <p class="description">面对编程挑战，我们如同雷霆，击破一切难题。</p>
        <p class="tips">开始你的编程之旅，你的道路没有岔口，因为未来，早已笃定。</p>
        <div class="link-to-other-page">
            <p style="white-space: pre-line;">
                好课推荐
                https://www.bilibili.com/video/BV1gc41117ta?p=3&spm_id_from=pageDriver&vd_source=d4b859b0532ebb11fd37c3b6f643100f
                1. protected, private, public, default这样的access modifier都解释一遍 并且用例子说明

                对于public修饰符，它具有最大的访问权限，可以访问任何一个在CLASSPATH下的类、接口、异常等。它往往用于对外的情况，也就是对象或类对外的一种接口的形式。
                这个权限比较高
                protected的权限排第二 不可以被外部包访问，但是子类啥的都行，包括本包和类内部。
                主要作用就是保护子类。
                相当于protected就是传递给子类的
                default的话，一般子类也不可以。只能本包和类的内部。
                而private最严格，本包都不行 只能类的内部可以。
                
                2. 
                @AuthenticationPrincipal User user：
这个注解自动地将当前经过认证的用户注入方法中。在Spring Security环境下，它通常用来获取代表当前用户的User对象。User是Spring Security提供的一个用户详情类，它包含了当前用户的信息，比如用户名、密码和授权
            3. JPA Repository
            JPA Repository refers to a set of interfaces in Spring Data JPA that abstracts away the boilerplate code required to perform CRUD (Create, Read, Update, Delete) operations on entities. When you extend interfaces like JpaRepository, Spring Data JPA automatically provides implementations for methods like save(), findAll(), findById(), deleteById(), etc.
            
            For example, JpaRepository is a JPA-specific extension of the Repository interface that comes with additional JPA-related methods. It provides a way to perform various operations on the entity, including finding, saving, and deleting records without needing to write any implementation code.
            
            These annotations and interfaces significantly reduce the amount of boilerplate code developers 
            @Entity
The @Entity annotation marks a class as a JPA entity. An entity represents a table stored in a database. Every instance of an entity corresponds to a row in the table. This annotation tells the JPA provider that the class should be mapped to a database table.

@Id
The @Id annotation marks a field as the primary key of the entity. The primary key uniquely identifies each entry in the database table. This annotation is placed on the field that maps to the primary key column of the table.

@GeneratedValue
The @GeneratedValue annotation is used in conjunction with @Id to specify the primary key generation strategy for the entity. It indicates that the persistence provider should automatically generate the primary key for the entities. The strategy attribute of @GeneratedValue allows you to select the primary key generation strategy, such as AUTO, SEQUENCE, IDENTITY, or TABLE. AUTO is the default strategy and lets the persistence provider choose the strategy based on the database capabilities.
4.@RestController is a special type of @Controller that contains the semantics of @ResponseBody, which means that the returned object will be automatically serialized into JSON and written into the HTTP response body
5.Why do we need to constantly serialize and deserialize JSON? This process is critical to the functionality of the REST API for several reasons:

Data exchange format: JSON is a lightweight data exchange format that can easily transfer data between different systems. Due to its simplicity and ease of human readability, it has become the de facto standard for data exchange in Web APIs.

Language-independence: JSON is a language-independent data format that does not rely on the specific structure of any programming language. This means that no matter what language the server and client are written in, they can communicate via JSON.

Network transfer: Network transfer usually involves the exchange of data in text format. Serialization converts an object or data structure into a JSON string so that it can be sent over network protocols such as HTTP. In contrast, deserialization converts the received JSON string back into the original object or data structure for use within the program.

Data storage: JSON format is also often used to store data (such as in databases) because it is very readable and concise.

Security: The serialization and deserialization process can serve as a simple form of data validation. When deserializing, you can check whether the JSON data conforms to the expected format, thereby avoiding problems caused by incorrect or malicious data structures.
6. why repo?
high-level abstraction. for data access and manipulation. rather writing custom data access code(such as sql queries)
provide a generic api for accessing and manipulating entities. 


Purpose of UserRepository Interface
The UserRepository interface, as an example, is designed to manage the data access operations for User entities. By extending JpaRepository, it inherits a set of methods for performing CRUD (Create, Read, Update, Delete) operations, as well as pagination and sorting functionality. Developers can also define custom query methods in this interface, and Spring Data JPA will automatically provide the implementation based on the method name or the custom query annotation (@Query). This greatly reduces the amount of boilerplate code required to interact with the database.
7 spring, SpringBoot
springboot是spring生态的产品
spring framework是一个容器框架
springboot不是一个框架 快速构建基于spring的脚手架
为开发spring生态其他框架铺平道路
2个不是一个层面的东西 没有可比性
8  springboot的核心注解
java config的配置版本（xml的配置直接跳到springboot的配置方式）
springbootapplication 启动类这里
当前应用是springboot应用
springboot configuration也是一个原注解
启动类是一个配置类
enableautoconfiguration这个注解就是用来启动自动配置类的，扫面所有能使用的自动配置类
自动配置类概念：springboot里的
很多自动配置类里面：autoconfiguration。
conditionalOnProperty
springboot单独提供出来的
conditionalonclass onbean这些都是核心注解

The image you've uploaded appears to be a screenshot of some text explaining various annotations related to Spring Boot's conditional registration of beans. Specifically, the text seems to be describing @Conditional annotations which are a series of annotations that allow you to conditionally register beans in the Spring context based on certain criteria. Let's go over them in English:

@ConditionalOnBean: This annotation is used to conditionally include a bean into the Spring ApplicationContext only if a bean with the specified name is already present in the ApplicationContext.

@ConditionalOnClass: This one is used to register a bean only if the specified classes are present in the classpath. It ensures that the bean will not be created if the required class is not found, preventing class-related errors.

@ConditionalOnExpression: This allows for the inclusion of a bean based on the result of a SpEL (Spring Expression Language) expression. It gives you a powerful way to control bean registration dynamically, based on the evaluation of the expression.

These annotations are part of Spring Boot's auto-configuration magic, which tries to automatically configure your Spring application based on the jar dependencies that you have added. They can be particularly useful for creating auto-configuration classes that conditionally define beans to auto-configure a Spring application according to the presence or absence of certain criteria.
9springboot bean
Yes, you can understand a bean as an object that contains all the information an object would have, and it can indeed be used for passing data, among other functionalities. To make this clearer, let's use a metaphor involving a coffee shop to explain the concept of beans, objects, and their roles within the Spring Framework.

The Coffee Shop Metaphor
Imagine you walk into a coffee shop (the Spring Framework) to get a cup of coffee (an object). This coffee shop is unique because it has a special service (the Spring IoC container) that prepares your coffee for you exactly how you like it without you having to do it yourself.

Coffee Beans (Spring Beans): Just as coffee beans are the essential ingredient to make a cup of coffee, Spring beans are the essential components used by the Spring Framework to create objects. These beans are not simple Java objects; they are special because the Spring container manages them. This means that the container creates these objects, configures them with the right settings (like how you might like your coffee with a specific amount of sugar and milk), and manages their entire lifecycle.

The Recipe (Bean Configuration): Before the coffee shop can make your coffee, they need to know how you like it. This is similar to defining a bean in Spring. You can tell Spring how to create your object (bean), what ingredients (dependencies) it needs, and other settings through configurations. This can be done in various ways, such as XML files, annotations, or Java config classes, much like how you can order your coffee verbally, write it down on a piece of paper, or select options on a touchscreen.

Making the Coffee (Object Instantiation): When you order your coffee, the coffee shop's service (Spring IoC container) goes to work. It takes the coffee beans (Spring beans), follows the recipe (bean configuration), and makes your coffee (object). This process is managed entirely by the coffee shop, so you don't have to grind the beans, boil the water, or mix the ingredients yourself. Similarly, Spring takes care of creating objects and managing them according to the defined configurations, so developers don't have to write boilerplate code for object creation, lifecycle management, and dependency resolution.

Serving the Coffee (Dependency Injection): If your coffee requires milk, the coffee shop adds milk to it before serving. This is like Spring's dependency injection. If a bean needs another bean to work (like a coffee needs milk), Spring ensures that the required bean is created and "injected" into the bean that needs it.

Enjoying Your Coffee (Using the Bean/Object): Finally, you get your coffee exactly how you like it, ready to drink. In your application, the Spring-managed beans are ready to be used wherever needed, configured and assembled according to your specifications.
In this metaphor, the coffee shop takes the responsibility off your hands and ensures your coffee is made correctly, just as Spring manages your objects (beans) and their dependencies, freeing you to focus on the more important parts of your application's logic.


10 springboot的自动配置原理
springbootconfiguration引入了enableautoconfiguration
enableautoconfiguration引入了import
spring容器启动时，加载loc容器会解析import注解
import导入了deferredImportSelector, 会使springboot的自动配置类的顺序在最后，这样方便我们扩展和覆盖
读取所有的meta-inf/spring.factories文件
过滤出所有autoconfigurationclass类型的类
最后通过condition排除无效的自动配置类
11springboot的启动原理
从spring.factories读取listener applicatinContextInitializer
启动类当作配置类传入进行初始化
applicationlistener监听器
推算当前web应用类型webapplicationtype
读取applicationconntextinitializer
new SpringApplication初始化信息
执行.run 加载了ioc容器
refresh方法 体现整个ioc加载过程
servletwebserverapplicationcontext
自动配置类概念：springboot里的记录启动时间
记录启动结束时间
输出启动耗时时间
调用很多监听器对外扩展
读取springapplicationrun监听器
12json stands for javascript object notation. lightweight format for storing and transporting data. 
jason is the most popular format for frontend and backend communications. 
13 how do we return responses in JSON format?
Springboot automcatically converts it to json format for you. 

14public record是什么
在Java中，public record是Java 14中引入的一种新特性，用于简洁地定义数据传输对象（DTO），它能够自动生成字段、构造函数、equals()、hashCode()和toString()方法。public record关键字用于声明一个record类，类似于传统的Java类，但其主要用途是为数据传输而设计的，即不可变的数据聚合。

在你提供的示例中，Person是一个record类，它有四个字段：name、company、homeAddress和favoriteBook。这些字段在声明时没有用private、protected或package-private修饰符修饰，因此它们默认是public的。

记录类不需要编写显式的构造函数，因为它们会自动生成一个公共的构造函数来初始化所有字段。此外，记录类还会自动生成equals()、hashCode()和toString()方法，这些方法会基于记录类的所有字段生成对应的实现。

你的示例中漏掉了record类的主体部分，它应该包含在花括号 {} 中间。在这个部分，你可以添加额外的方法或者其他成员。

15耦合度
耦合度是软件工程中描述模块之间相互依赖程度的概念。它表示一个模块对其他模块的依赖程度，或者说一个模块内部的元素之间的依赖程度。耦合度越低，表示模块之间的独立性越高，修改一个模块不会对其他模块造成太大影响，提高了系统的灵活性、可维护性和可扩展性。

在软件设计中，通常会努力降低耦合度，以提高代码的质量和可维护性。有几种类型的耦合度，包括：

低耦合（Loose Coupling）：模块之间的依赖程度很低，它们之间的关系较为独立，修改一个模块不会对其他模块造成影响。这种情况下，系统的可维护性和可扩展性会更好。

高耦合（Tight Coupling）：模块之间的依赖程度很高，它们之间的关系紧密，修改一个模块可能会导致其他模块的修改。这种情况下，系统的灵活性会受到影响，维护和扩展会更加困难。

无耦合（No Coupling）：模块之间完全独立，彼此没有任何依赖关系。这种情况下，修改一个模块不会影响其他任何模块，但在实际应用中很难实现。

降低耦合度的方法包括使用接口而不是具体实现、使用依赖注入、使用设计模式等。通过合理设计和组织代码，可以有效地降低模块之间的耦合度，提高系统的可维护性和可扩展性。


16
在这段代码中，@RequestParam是Spring框架中的注解，用于从HTTP请求中获取查询参数（Query Parameter）。在hello方法中，locale参数使用@RequestParam注解标记，这表示该参数可以从HTTP请求的查询字符串中提取，并且是可选的（因为设置了required = false）。如果请求中没有提供locale参数，它将默认为"en_US"。

具体来说，@RequestParam注解用于指定要映射到方法参数的查询参数的名称。在这个例子中，locale参数是通过@RequestParam注解指定的，它表示接收名为locale的查询参数的值。

17
create table persons(
    person_id INTEGER,
    last_name text,
    first_name text,
    address text
)
insert into persons(c1, c2, c3, c4) 
values (v1, v2, v3, v4)
values可以是单引号括好的
delete from table where condition 
用;进行结尾


18 springJDBC 和runtimeOnly
Spring JDBC 是 Spring Framework 提供的一个库，用于简化数据库访问和操作。它处理了传统的 JDBC 编程涉及的常见问题，如打开和关闭连接，处理异常，管理资源等。使用 Spring JDBC，开发人员不必编写冗长的代码来执行基本的数据库操作。它提供了一个模板类JdbcTemplate，可以大大减少编码量。

在传统的 JDBC 代码中，开发人员需要写很多样板代码来处理异常、管理事务、关闭连接等。JdbcTemplate接管了这些常规任务，允许开发人员专注于他们的特定数据库逻辑。Spring 还提供了一种声明式的事务管理方式，可以更加灵活地管理事务。

关于runtimeOnly在 Gradle 的 build 脚本中的含义：

Gradle 是一个项目自动构建工具，它用于自动化应用程序的构建过程。在 Gradle 中，依赖管理是非常重要的部分。依赖可以有不同的配置，决定了库是如何在项目的不同阶段中被包含和使用的。

runtimeOnly 是 Gradle 中的一个配置，它意味着这个依赖将不会在编译时被包括，而只会在运行时被包括。这通常用于那些不需要在编译时参与代码的编译过程，但在运行时提供必要功能的库，比如数据库连接驱动。

例如，如果你在 Gradle 的 build 脚本中这样配置 PostgreSQL 的驱动：

groovy
Copy code
runtimeOnly 'org.postgresql:postgresql:版本号'
这意味着 PostgreSQL 驱动只会在运行时被添加到应用程序的类路径中，编译项目代码时不会包含这个驱动。这通常是因为在开发阶段，代码只需要知道 JDBC 接口，并不需要知道特定数据库的实现细节。这样做可以减少构建过程的复杂性，并减小构建产物的大小。在运行时，当应用程序实际连接数据库时，需要具体的数据库驱动来实现连接。

</p>
        </div>
    </div>
</body>
</html>
