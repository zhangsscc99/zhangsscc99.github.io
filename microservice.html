<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>图论专题</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        .main-title {
            color: #007BFF;
            font-size: 2em;
            text-align: center;
        }
        .content {
            margin-top: 20px;
        }
        .code-block {
            background-color: #f4f4f4;
            border-left: 3px solid #007BFF;
            padding: 10px;
            margin: 20px 0;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .link-to-other {
            display: block;
            margin-top: 20px;
            text-align: center;
            font-size: 1em;
            color: #28a745;
        }
    </style>
</head>
<body>
    <div class="content">
        <div class="link-to-other-page">
            <a href="index.html">首页/返回</a>
        </div>
        <h1 class="main-title">MapReduce</h1>
        <p></p>
        <div class="toc">
            <h2>Table of Contents</h2>
            <div class="toc-item"><a href="#section1">面试经验</a></div>
            <div class="toc-item"><a href="#section2">3月学习计划</a></div>
            <div class="toc-item"><a href="#section3">简历修改和公司调查</a></div>
            <div class="toc-item"><a href="#section4">简历和公司匹配度</a></div>
            <div class="toc-item"><a href="#section5">八股文（http）</a></div>
            
        </div>

        
        <h2></h2>
        <pre class="code-block">

        
            
        </pre>
        <div class="section" id="section1"></div>
        <p style="white-space: pre-line;">
            1. 服务集群  
            分布式缓存。 分布式搜索。
            服务网关。
            消息队列。  
            分布式日志服务。 
            系统监控。链路追踪。 
            配置中心，注册中心。jenkins微服务项目自动化部署，k8s。

            完整的微服务技术栈。
            jenkins k8s

            实用篇。
            高级篇 微服务技术难点。 复杂技术。


            2 认识微服务实现
            spring cloud。  
            所有功能集中在一个项目中开发，打成一个包部署 
            架构简单 部署成本低
            耦合度高

            分布式架构  
            业务功能对系统做拆分。每个业务作为独立项目开发。称为一个服务。
            降低服务耦合。有利于服务拓展。

            拆分问题：部署在独立机器上，一个向另一个发请求，跨越机器的调用。
            服务拆分粒度。服务集群地址如何维护？
            服务之间如何实现远程调用。
            服务健康状态如何感知。
            dubbo是什么呢，分布式技术。
            升级迭代，微服务方案比较火。
            经过良好架构设计的分布式架构方案，微服务架构特征。
            拆分粒度小，每个服务对应唯一的业务能力，单一职责，避免重复业务开发。
            进一步拆分。

            微服务对外暴露业务接口。
            面向服务。部署独立，数据独立，技术独立，团队独立。
            按照微服务派发。前端，服务端，测试，运维，5-8人都行。服务迭代升级，快速定下来。
            会员服务，用户服务，积分服务。擅长的技术。自己随便选，大家术业有专攻。
            数据库。  
            隔离性强。服务调用做好隔离，容错，降级，避免出现级联问题。
            高内聚，低耦合。架构非常复杂，运维，监控，部署难度提高。

            微服务落地技术。springcloud和阿里巴巴的dubbo。
            微服务拆分，集群。接口暴露。调用。
            服务集群，注册中心，维护各个节点状态。
            配置中心，管理整个微服务群的配置。
            微服务上线，访问。服务网关。请求路由，负载均衡。
            

            dubbo 服务远程调用 dubbo协议。  
            zookeeper，redis是注册中心，没有配置中心。没有服务网关。dubbo-admin，功能弱。
            spring cloud集大成者。eureka，consul。feign http协议。
            sringcloud gateway，zuul。
            服务网关gateway，响应式服务，吞吐能力非常强。
            SpringCloud的开源组件的集大成者。
            SpringCloudAlibaba，nacos, eureka, dubbo, feign, springcloudconfig, nacos, 
            springcloudgateway, zuul, sentinel, 
            hystrix服务监控和保护。


            3 springcloud 最广泛的微服务框架。
            app登录 手动加密 md5 + 随机字符串  
            md5基础上手动加盐处理。 salt。  
            根据用户生成salt，随机字符串。 
            根据用户名查询用户。
            用户输入密码加数据库中的salt md5加密。 
            比对密码。 


            4 要见多识广 技术面光 业务面广
            web3的知识也要了解 blockchain。aigc。
            chatgpt。LLM。  


            5  nacos: 服务发现和配置管理 
            构建云原生应用。
            动态服务发现和配置管理问题。
            动态dns服务。
            分布式服务协调系统。zookeeper。 
            解决一致性问题。 
            协调分布式应用的中心化服务。


            为什么在linux系统里启动nacos服务
ChatGPT
在 Linux 系统上启动 Nacos 服务是常见的做法，原因涉及到多个方面，包括 Linux 系统的稳定性、性能、安全性、以及开源社区的支持等。下面是一些具体的原因为什么在 Linux 系统里启动 Nacos 服务是一个好的选择：

稳定性和可靠性：Linux 系统以其稳定性和可靠性而闻名，这对于确保 Nacos 服务的连续运行非常重要。服务发现和配置管理作为微服务架构的核心组件，需要24/7不间断运行，Linux 提供了这方面的保障。

性能：Linux 系统通常能提供比其他操作系统更好的性能。Linux 内核和网络栈都经过优化，能够处理大量并发连接和高吞吐量，这对于 Nacos 这样的中间件来说是非常重要的。

安全性：Linux 提供了强大的安全特性，如 SELinux、AppArmor 以及各种网络安全机制，有助于保护 Nacos 服务免受攻击。

开源和成本效益：Linux 是开源的，这意味着你可以自由使用而不需要支付额外的许可费用，这对于希望降低成本的企业尤其重要。同时，Nacos 也是开源的，两者搭配使用可以最大化地降低成本。

社区支持：Linux 有一个庞大且活跃的开源社区，可以为遇到问题的用户提供支持和解决方案。同样，Nacos 也拥有一个活跃的社区，用户可以从中获得帮助和最佳实践分享。

灵活性和可扩展性：Linux 系统提供了极高的灵活性和可配置性，用户可以根据自己的需要进行定制和优化。这使得 Linux 成为运行 Nacos 等需要高度定制化设置的中间件的理想选择。

环境一致性：在开发和生产环境中使用相同的操作系统（如 Linux）可以避免许多环境不一致导致的问题。由于 Linux 在云环境和数据中心中的广泛应用，使用 Linux 可以使得从开发到部署的过程更加顺畅。

基于以上原因，在 Linux 系统中启动 Nacos 服务是十分常见和推荐的做法，特别是在需要高性能、高可靠性和高安全性的生产环境中。


6 mybatis是什么 
mybatis是什么
ChatGPT
MyBatis 是一个流行的 Java 持久层框架，它提供了对象关系映射（ORM）的功能，允许将 Java 对象与数据库中的表进行映射，从而简化了数据库操作。与其他 ORM 框架如 Hibernate 相比，MyBatis 提供了更为直接和简单的方式来处理数据库操作，它允许开发者通过编写 SQL 语句来进行精细的数据库操作控制，而不是完全依赖于框架生成的 SQL。

MyBatis 的关键特点包括：
简单易用：MyBatis 的配置和使用都比较简单，开发者可以很容易地集成 MyBatis 到现有的项目中，并快速开始工作。

灵活：MyBatis 允许开发者直接编写 SQL 语句，这为处理复杂的数据库操作提供了极大的灵活性。开发者可以根据需要优化 SQL，以获得更好的性能。

动态 SQL：MyBatis 支持动态 SQL 语句的构建，使得 SQL 语句的编写更加灵活和强大。这对于需要根据不同条件生成不同 SQL 语句的场景特别有用。

映射器（Mapper）：MyBatis 通过映射器将 Java 方法与 SQL 语句关联起来，这使得数据库操作更加直观和类型安全。映射器可以是 XML 文件或者接口加注解的形式。

会话管理：MyBatis 提供了会话管理和事务控制的功能，允许开发者在需要的时候进行事务管理和会话控制。

集成支持：MyBatis 可以与 Spring、Spring Boot 等流行的 Java 框架无缝集成，这使得在这些框架中使用 MyBatis 变得非常方便。

使用场景：
MyBatis 特别适用于那些对数据库操作有特殊需求，需要手写 SQL 以获取更高性能或处理复杂查询的项目。由于它允许直接控制 SQL 语句，因此对于那些需要细粒度控制数据库交互的应用来说，MyBatis 是一个很好的选择。

总的来说，MyBatis 是一个强大且灵活的 ORM 框架，它结合了直接使用 SQL 的灵活性和 ORM 的便捷性，适用于各种规模的 Java 应用项目。

7 所有微服务结构都类似。  
loginDto.  
login_auth.  
接口定义。版本号方便配置。
ResponseResult.  
Post请求方式。  
数据库分页查询。


8 接口分析
idea功能实现。



9 service接口解耦代码
mapper是一个接口。 mybatis里。
mapper
什么是 mapper： 在 MyBatis 中，mapper 是一个接口，它定义了与数据库交互的方法。这些方法直接对应于 SQL 语句。每个方法都关联了一个在 mapper XML 文件中定义的 SQL 语句，或者是注解中定义的 SQL。当你调用这个接口的方法时，MyBatis 会执行对应的 SQL 并返回结果。

为什么是接口： MyBatis 使用接口加 XML 或注解的方式来定义 mapper，这样做有几个好处。首先，它实现了关注点分离，SQL 和 Java 代码被分开管理。其次，接口为动态代理提供了可能，MyBatis 在底层创建了这个接口的代理实现，在这个代理中注入了 SQL 执行的逻辑。这使得代码更加简洁，并且更易于维护和测试。

service
service 接口： 在 Spring 或类似的框架中，service 层通常用于定义业务逻辑的抽象。接口定义了应该完成的任务和操作，但不涉及具体的实现。

service 实现类（impl）： 实现类 ApUserServiceImpl 是 ApUserService 接口的具体实现。它包含了实际的业务逻辑，调用 mapper 层的接口与数据库进行交互。

为什么 service 还得是接口： 将 service 定义为接口有几个原因。首先，它为不同的实现提供了可能性，这在多种实现必须根据不同情况替换时非常有用。其次，它有助于解耦代码，因为高层模块（如控制器或其他服务）只依赖于抽象，而不是具体的实现，这样有助于测试和后续的代码维护。最后，接口也有利于使用 Spring 的依赖注入特性，提高代码的模块性和灵活性。

简而言之，这种使用接口定义层次和职责的架构风格，有助于保持代码的整洁和可维护性，同时为测试、调试和后续可能的功能扩展提供便利。


10 动态代理  
功能扩展提供便利。

User
什么是动态代理
ChatGPT
动态代理是一种设计模式，它允许程序在运行时动态地创建代理类和代理对象。在 Java 中，动态代理通常通过 java.lang.reflect.Proxy 类和 java.lang.reflect.InvocationHandler 接口来实现。这种机制使得你可以在运行时创建一个实现了一或多个接口的代理对象，而不需要为每个接口编写实现类。

这个代理对象在所有方法调用上作为一个中间层，可以用来进行方法拦截、方法调用前后执行额外的处理（比如日志记录、权限检查、事务处理、延迟加载等），然后根据需要将调用转发到实际对象。

动态代理的工作原理
定义一个接口：你有一个或多个方法的接口定义。
创建 InvocationHandler：实现 InvocationHandler 接口，定义一个调用处理器，它将决定代理对象的方法调用如何被处理。
创建代理对象：通过 Proxy 类的 newProxyInstance 方法动态创建代理对象，这个方法需要三个参数：类加载器、一组接口以及刚才创建的调用处理器。
使用代理对象：使用返回的代理对象就像使用其它任何实现了接口的对象一样。
动态代理的用途
动态代理在许多场景中都很有用，例如：

AOP（面向切面编程）：在 AOP 中，动态代理可以用来实现方法的拦截，为方法调用提供事务管理、日志记录、权限检查等横切关注点。
测试和模拟：动态代理可以用来动态创建模拟对象，用于测试没有实现类的接口。
远程方法调用（如 RMI、RPC）：动态代理可以代理远程对象，使得调用远程方法就像调用本地方法一样。
数据库ORM框架：如 MyBatis，使用动态代理技术生成 Mapper 接口的实现，从而避免了手动编写 DAO 实现的工作。


11 dao(hibernate, spring jpa), dto, mapper(mybatis), entity
在 Spring 框架的上下文中，DAO（Data Access Object）通常指的是一个旧的模式，用于封装数据库操作的代码。而当你提到 Spring Data JPA 或 Spring Data JDBC 的 repository 接口时，它们实际上是 DAO 的一种现代替代品，提供了更高级的数据持久层抽象。

Repository Interface
Spring Data 提供了 Repository 接口，这是一种高级抽象，它封装了数据存储的访问逻辑。Spring Data Repository 接口的目的是简化数据访问层的代码，并减少样板代码。在 Spring Data JPA 中，这通常与 ORM 框架如 Hibernate 配合使用；在 Spring Data JDBC 中，它直接与数据库交互。

Repository 的特点
减少样板代码：Spring Data Repository 接口可以自动实现许多常见的数据访问操作，无需编写实现代码。
方法签名查询：你可以通过定义方法签名来创建查询，Spring Data 会提供实现。例如，findByUsername(String username) 就会生成一个根据用户名查询的操作。
支持多种存储策略：Spring Data 提供了对不同数据存储策略的支持，比如关系数据库、NoSQL 数据库、REST API 等。
Repository 接口与 DAO 的对比
DAO：传统上用于抽象化数据访问逻辑，通常需要手动编写实现和管理 SQL 语句或 ORM 实体。
Repository：在 Spring Data 中，是一种更高级的抽象，它扩展了 CrudRepository 或 PagingAndSortingRepository 接口。它们通常不需要显式的实现，因为 Spring Data 可以根据方法命名策略自动提供实现。
在 Spring Data 中，repository 接口扮演了 DAO 的角色，但以一种更声明性和更少编码的方式来实现。你不需要写实现类；Spring Data 会为你的接口生成代理实现，执行必要的数据库操作。这使得数据访问层更加简洁，易于开发和维护。




12
事务的概念
事务通常指的是一组必须作为一个整体执行的操作序列，它们要么全部成功，要么全部失败。在数据库管理系统中，事务必须满足 ACID 属性，即原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。

原子性：事务中的所有操作要么全部执行，要么全部不执行。
一致性：事务执行的结果必须使数据库从一个一致性状态转换到另一个一致性状态。
隔离性：并发执行的事务彼此独立，不会互相干扰。
持久性：一旦事务提交，其结果就是永久性的，即使发生系统故障也不会丢失。


13 做项目中途跟着源码一起看
仔细看源码 多查具体的知识 google或者chatgpt。
视频多看几遍就可以了 源码里记笔记。
讲义

14 悲观锁  
pessimistic lock。  
每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁。
乐观锁 
optimistic lock。  
每次去拿数据的时候都认为别人不会修改。所以不会上锁。但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，
可以使用版本号等机制。

乐观锁适合读操作多、写操作少的场景，因为这种场景下冲突的概率较低，可以减少锁的开销，提高系统的并发能力。而悲观锁更适合写操作频繁的场景，因为它可以确保数据的一致性和安全性。在实际应用中，根据具体的业务需求和并发级别选择合适的锁策略是很重要的。





图的支线
15connected component- graph


16 15-20k mq  
消息一致性问题。
基础的中高级
40万以上肯定更难。基础内容肯定要会。
http请求。  高并发的情况下。
tomcat最大线程数。
客户端，tomcat服务器端。
请求，响应。http请求。
50个线程，接收到客户端请求。
堆积请求。
线程池。不能丢失请求，装到队列里面去，堆积请求过多。
tomcat服务器端崩溃。

17 阻塞队列
使用阻塞队列的主要原因包括：

线程间协调与同步： 在多线程编程中，阻塞队列可以用于协调不同线程之间的数据交换和同步操作。当一个线程需要等待另一个线程产生数据时，它可以从阻塞队列中获取数据，如果队列为空，则该线程会被阻塞，直到队列中有数据可用。

简化编程： 阻塞队列提供了一种简单而有效的方法来处理生产者-消费者问题。生产者线程可以将数据插入队列中，而消费者线程可以从队列中获取数据。由于阻塞队列处理了线程的阻塞和唤醒操作，因此编程者可以专注于业务逻辑，而不必编写复杂的线程同步代码。

平衡系统负载： 阻塞队列可以用于平衡系统的负载。当生产者产生数据的速度快于消费者处理数据的速度时，阻塞队列可以暂时保存数据，避免数据丢失或系统资源过度消耗。反之亦然，当消费者速度快于生产者时，阻塞队列可以阻塞消费者线程，避免资源浪费。

提高系统吞吐量和性能： 使用阻塞队列可以避免线程的频繁切换和竞争条件的产生，从而提高系统的吞吐量和性能。相比于手动编写线程同步代码，阻塞队列通常能够更好地利用系统资源，提高并发性能。

总的来说，使用阻塞队列可以简化多线程编程，提高系统的可维护性和性能，并有效解决线程间的协调与同步问题。


User
就是一个加满加不进去了 一个空了取不出来了 是吗
ChatGPT
是的，您描述得很准确。阻塞队列在队列已满时会阻塞生产者线程，直到队列中有空余空间；在队列为空时会阻塞消费者线程，直到队列中有新的元素可用。这种行为确保了生产者和消费者之间的协调和同步，从而有效地处理了线程间的竞争条件和资源争夺问题。


18 单机版本mq


19 联网版本mq
kafka很复杂。运行在什么环境 什么操作系统。
手写kafka。


20 netty and nio  
什么是netty
ChatGPT
Netty是一个基于Java NIO（Non-blocking I/O，非阻塞I/O）的网络编程框架，它提供了简单易用的API，用于快速开发高性能、可扩展的网络应用程序。Netty的设计目标是提供一种简单、高效、稳定的网络编程解决方案，以满足现代网络应用程序对性能和可靠性的需求。

Netty的主要特点包括：

异步和事件驱动： Netty基于事件驱动模型，使用异步的方式处理网络操作。它通过回调、Future和Promise等机制实现了非阻塞的I/O操作，避免了线程阻塞，提高了系统的并发性能。

高性能： Netty采用了零拷贝技术和内存池管理，以及高效的事件循环机制，能够处理大量的并发连接和高负载的网络流量，从而实现了较高的性能。

简单易用： Netty提供了简洁而灵活的API，使开发者能够轻松地构建各种类型的网络应用程序。它提供了丰富的功能模块和组件，如编解码器、处理器链、事件处理器等，帮助开发者快速实现复杂的网络通信逻辑。

可扩展性： Netty的设计具有良好的可扩展性，开发者可以通过定制编解码器、处理器等组件来满足不同的需求。同时，Netty支持模块化的架构设计，使得用户能够灵活地扩展和定制框架的功能。

跨平台： Netty是基于Java NIO实现的，能够在各种平台上运行，包括Windows、Linux、macOS等，同时也支持Android平台。

总的来说，Netty是一个功能强大、性能优越、易于使用的网络编程框架，被广泛应用于构建各种类型的网络应用程序，包括Web服务器、代理服务器、游戏服务器、实时通信系统等。

User
什么是java nio
ChatGPT
Java NIO（New I/O，新I/O）是Java平台提供的一套用于非阻塞I/O操作的API和框架。它引入了一种新的I/O模型，即非阻塞I/O模型，以替代传统的阻塞I/O模型。

Java NIO 主要包含以下核心组件：

通道（Channel）： 通道是 Java NIO 中的一个重要概念，它代表了一个连接到实体（如文件、网络套接字）的开放的双向通信路径。通道提供了非阻塞的读写操作，并且可以同时支持读写操作，因此在高并发的网络编程场景中表现出色。

缓冲区（Buffer）： 缓冲区是 NIO 中用于数据存储和传输的容器。所有的数据都必须经过缓冲区进行传输。Java NIO 提供了多种类型的缓冲区，如 ByteBuffer、CharBuffer、IntBuffer 等，用于存储不同类型的数据。

选择器（Selector）： 选择器是 Java NIO 中实现多路复用的关键组件。它可以通过单个线程监控多个通道的事件，比传统的阻塞I/O模型更高效，可以极大地提高网络编程的性能和并发处理能力。

Java NIO 主要用于构建高性能、高并发的网络应用程序，例如网络服务器、代理服务器、消息中间件等。与传统的阻塞I/O模型相比，Java NIO 提供了更加灵活和高效的方式来处理I/O操作，尤其适用于需要处理大量并发连接的场景。


netty 网络编程框架
网络操作。非阻塞io操作。


21 生产者投递消息给mq服务器端，mq服务器端需要缓存该消息。
mq服务器宕机之后，消息如何保证不丢失。
手写过多线程单机mq。
1持久化机制。
消费者不在 mq的消息不会丢失。
消费者消费 mq服务器端才会删除该消息。
mq队列服务器端
生产者角色  消费者角色。
mq服务器端 将消息推送给消费者
消费者已经和mq服务器端 保持长连接。
消费者主动拉取消息。
mq如何实现抗高并发
mq异步。
延迟问题。
10万条 mq服务器端。消费者可能一条条消费。
10万条消息。先发 后发。
延迟问题。
考虑mq消费者提高速率的问题。
消费者实现集群。 批量获取消息即可。  
多个消费者。
避免消息堆积。
提高消费者速率。（mq集群）。
mq如何避免消息堆积。



22 













            