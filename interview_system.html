<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>图论专题</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        .main-title {
            color: #007BFF;
            font-size: 2em;
            text-align: center;
        }
        .content {
            margin-top: 20px;
        }
        .code-block {
            background-color: #f4f4f4;
            border-left: 3px solid #007BFF;
            padding: 10px;
            margin: 20px 0;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .link-to-other {
            display: block;
            margin-top: 20px;
            text-align: center;
            font-size: 1em;
            color: #28a745;
        }
    </style>
</head>
<body>
    <div class="content">
        <div class="link-to-other-page">
            <a href="index.html">首页/返回</a>
        </div>
        <h1 class="main-title">MapReduce</h1>
        <p></p>
        <div class="toc">
            <h2>Table of Contents</h2>
            <div class="toc-item"><a href="#section1">面试经验</a></div>
            <div class="toc-item"><a href="#section2">3月学习计划</a></div>
            <div class="toc-item"><a href="#section3">简历修改和公司调查</a></div>
            <div class="toc-item"><a href="#section4">简历和公司匹配度</a></div>
            <div class="toc-item"><a href="#section5">八股文（http）</a></div>
            
        </div>

        
        <h2></h2>
        <pre class="code-block">

        
            
        </pre>
        <div class="section" id="section1"></div>
        <p style="white-space: pre-line;">
            1. message broker1
            name server
            topic相关的所有信息。
            partition有自己对应的指针。
            producer。admin创建的topic。
            

            2 你在项目中遇到的难题
            考察经验阅历 和思路方法。不要care一味的难。
            复杂的查询手段。提炼难解决的问题。
            常见还是偏门。不要紧。互联网研发，偏门不一定难解决，常见不一定简单。
            偏门可能无关。常见而且难的。
            正常问题还是踩坑问题。

            3交易一致性问题。
            重复支付。
            超时退的问题。
            交易请求。
            用户下单 交易系统 insert交易记录。
            status = 初始。
            支付系统。
            下单支付。支付成功 异步的方式通知的。
            回调。回馈。
            有延迟。重试了怎么办。接受支付消息。每隔一段时间又发了。
            已经success，支付系统又来了，update status成功，又发货。make payment，发货两次。
            引入一个操作。分布式系统里的防重操作。
            伪代码sql语句怎么写。做一次select查询。
            select * from order_info where id = "20201020"
            java代码判断status == “初始” 执行3 否则直接返回。
            update order_info set status = "成功" where id = 20201020
            网络时差 时延

            伪防重。防重幂等。
            悲观锁的方式：begin一个transaction。
            1. select * from order_info where id = "20201020" for update.
            加record lock。一旦有第二个发送 一样for update。没有commit和rollback。
            record lock没有释放，阻塞。

            使用乐观锁。begin transaction。java代码判断status == 初始。执行3 
            否则直接返回rollback。

            2. 超时退的问题。
            商品系统回滚库存。营销系统回滚优惠券。
            商品系统。 回滚操作，分布式事务有要求。
            回滚内容。回滚失败如何解决。重复回滚如何预防。
            cap原理 consistency 一致性 客户端知道这些操作都会发生。
            分布式。可用性。每个操作都必须可以预期的响应结束。
            分区容错性。partition tolerance. 单个组件无法可用，操作依然可以完成。

            3 分布式事务。
            二阶段提交。
            异步确保型。
            事务型消息。
            raft协议。
            读写相等。

            4 mysql
            client server. 
            单点的问题 begin 开启对应的事务。 对应的执行 execute。
            commit或者rollback。
            事务提交的过程和阶段。
            client 多个server 。
            server1和server2

            transaction manager. 事务操作请求。
            交易系统的交易模型。
            营销系统。
            二阶段的方式 1和2 server 发送prepare请求。
            两次prepare 开启本地事务 对应库存的扣减可以成功的。
            事务提交到数据库里。prepare ack1 和prepare ack2发送给对应的transaction manager。 
            库存扣减。发起真正意义上的commit。commit2.
            对应的server1和2 反馈给transaction manager。 
            整个二阶段提交的事务执行成功。


            排它锁。为了consistency牺牲掉了availability。


            5 网络安全必须要的
            大厂需要安全部门
            网络状态很复杂。层出不穷的系统安全问题。
            安全事件会摧毁企业形象。安全不是伴随着java开发运作的。
            系统上线前 排期很紧张。研发 测试 上线。
            测试上线之间 安全行为检测。安全问题 安全部同事block住。
            业务指标 1月前上线。动到交互设计 上线前都是折磨。
            重新开发 重新测试。不安全的行为和接口。
            p0级别的安全事故 48小时内做的事情。
            安全设计的理念和观念。
            网络 网络安全 分布式系统 
            那安全部只要把关就可以了。
            sql注入的原理 如果drop database被注入了 就很麻烦了。对输入做校验。
            隔断符号要处理。
            输入校验。占位符拼接。mybatis里面#和$的区别。
            dollar符号和井号。两种方式。code review。sql语句都是拷贝，不会手写。
            $符号拷贝 不会用预编译的sql 而是字符串拼接。$ 严重的危机 被sql注入的风险。

            6 原栈 xss
            html页面。网站的广告位。html的信息返回给web browser client。
            获取browser内部的cookie。用户信息泄露。重大影响。反射型的xss。广告位
            js代码 很多工作的 存储型的内容去做的。
            攻击者的评论。open api 发到原栈。发布评论。
            不断跳alert。骚扰类的 alert。如果一些真正攻击类的script。document.getcookie 
            post请求 用用户的信息 往原栈post请求。伪造用户的cookie发送请求。
            攻击站。转账请求 高危。xss。用脚本语言特性 浏览器上执行 模拟用户行为。
            入口层面 输入做校验。数据都要数据库中才能拉取。关键字做拦截。script绝对不可以进入系统。
            做替换。script执行请求就没有了。
            拦截用户非法请求，没法100%。限制太死 反而拦截正常的内容。
            保护用户cookie。cookie泄露。设置cookie为http-only返回形式。script脚本语言获取用户的cookie。
            http only的访问方式 而不是脚本。

            7 csrf 跨域
            email攻击手段。
            打开攻击站b的链接。
            同样的session。打开链接的时候，攻击站b返回一个转账url。
            跨站攻击，利用浏览器同源的特性。

            8 cookie hash 
            cookie是hash出来的
            没有办法获取cookie信息的 
            没办法猜到提供给浏览器的cookie。校验。抵挡攻击行为。
            web token  这是最好的。
            还是要思路灵活。其实spam预防 ml和nlp方法也可以。
            读取到原栈a的特性。
            web token做类似策略。
            cookie方式的伪造。
            csrf 请求。
            请求体的方式。伪造用户浏览内容。加入cookie以外的拦截校验。


            9尽管有运维或者中间件。
            云模式 可视化点点点就能线上部署。但是如果是全面化人才，docker k8s 标配。
            设身处地地操作实践 侃侃而谈 做加分项目。
            部门精力 手上两个候选人 容器化部署的 经验 不需要运维人员打配合。肯定要能力更强的这个。
            云原生。不需要运维研发。
            不需要特别细节的研究。
            隔离进程。用户，网络，ipc和uts等的基础。
            隔离操作系统环境。
            namespace. 
            cgroups 控制组限制硬件资源。
            unionfs做了镜像管理。
            虚拟机的区别。
            maven repo做了镜像管理。
            部署在docker内，不需要mysql的docker，而是用镜像。
            springboot 需要java虚拟环境，只需要镜像基础上加上内容。
            springboot镜像。

            docker和应用程序没有区别 启动时间很快 秒级别一般就够了
            轻量级的。
            用户进程没区别。进程和系统的区别。

            10 java thread poll executor
            coreSize 核心线程数。
            maxSize 最大线程数。
            queueSize 等待队列数。
            keepAliveTime空闲线程多久被销毁。
            handler 拒绝策略。


            11 系统地学习各种碎片的知识。rabbitmq
            镜像队列 消息队列的可靠性和可用性。负载均衡。
            还有面试题 
            异步发送和接受。在应用程序之间传递消息的通信方式。
            应用解耦。
            订单系统。库存系统。
            物流系统。
            通知库存系统。
            引入mq之后，mq会负责分别发送给库存和物流系统。
            服务挂掉了，整个系统下单失败。解耦。
            写入mq就可以下单成功，不管库存系统好了没。
            提高系统的容错。fault tolerant。
            从注册到响应 有延迟。500ms到320ms 邮件通知和短信通知。
            mq异步 邮件通知和短信通知。

            秒杀场景下。 每秒1w请求。订单服务每秒处理1k请求。
            引入mq以后。mq 每次拉取1k请求，慢慢处理。每秒处理1k请求。分批 不同的batch。

            降低可用性 外部依赖多了。
            复杂度高了。保证消息没有被重复。
            数据不一致。

            12 amqp协议
            交换机 多个队列 load这些消息。
            队列存储消息 说白了就是处理顺序决定了数据结构而已。


            13 jpa
            在Spring Boot项目中，虽然数据库已经存在，但你仍需要定义实体类来表示数据库表中的行，因为这是Java程序与数据库进行交互的方式。

实体类是使用Java Persistence API（JPA）定义的，它是一种ORM（对象关系映射）规范，允许你使用面向对象的方式来操作数据库。@Entity和@Table注解告诉Spring框架这个类应该被当作一个实体来处理，并且与一个特定的数据库表映射。@Id注解用于指定类的属性映射到表的主键。

通过这种映射，你可以在Java代码中操作这些实体对象，而不是直接使用SQL查询。这使得代码更容易理解和维护，同时也减少了直接处理SQL查询时可能出现的错误。

以下是为什么在Spring Boot项目中需要这些实体类的主要原因：

抽象: 实体类提供了数据库表的高级抽象，允许开发者使用面向对象的方法来操作数据。

简化数据访问: 使用Spring Data JPA等框架可以极大简化数据库操作，如增删查改等。

类型安全: 编译时的类型检查减少了运行时错误的可能性。

自动化: 许多数据库操作可以自动化，如自动生成查询。

解耦: 代码和数据库逻辑的解耦有利于维护和测试。

因此，即便数据库已经存在，这些实体类是连接数据库与Java应用程序的重要桥梁。
ORM: object relational mapping


14 编写代码来进行测试有几个重要原因，即使可以通过人工方式测试应用程序：

自动化：编写测试代码允许自动化测试过程。这意味着测试可以快速且一致地重复执行，而不需要人工干预。每次代码变更后，都可以自动运行测试来确保变更没有引入任何问题。

可靠性和准确性：人工测试可能会因疏忽或误解而导致错误。自动化测试每次都会以相同的方式执行，减少了由于人为因素造成的错误。

时间和成本效益：虽然初期编写测试代码可能需要时间和精力，但长期来看，自动化测试可以节省大量的时间。一旦编写，就可以在不增加额外成本的情况下多次执行这些测试。

文档作用：测试代码也可以作为项目的活文档。通过阅读测试，可以理解代码的预期行为和使用方式。

持续集成/持续部署（CI/CD）：自动化测试是CI/CD实践的基石。在CI/CD管道中，每次代码提交都会触发自动化构建和测试过程，确保新代码集成后应用程序仍然稳定。

早期问题发现：通过编写测试，可以在代码部署到生产环境之前发现问题。这种“预防胜于治疗”的方法可以避免未来的用户遇到这些问题，提高用户满意度。

回归测试：在软件开发过程中，新增功能或修复bug可能会导致旧代码出现问题。自动化测试可以确保现有功能在新变更引入后继续正常工作。

优化性能：性能测试通常很难通过手动测试完成，特别是需要模拟多用户或高负载情况时。自动化测试可以在不同的性能级别上执行，以确保应用程序表现良好。

jmeter性能测试 这个很有用的。

15 document object model 
web page. 
document object represents your web page

16 可用性 一致性
主节点 从节点。
服务集群。
服务集群3个 。 
岁月静好的图片。
集群之间的调用访问失败。
不能保证一致性 有致命后果。
可用性也很重要。
当网络分区发生时：

如果系统保证一致性，那么它可能需要在分区的不同部分之间停止操作，直到一致性能够再次被保证。在这个过程中，系统可能无法对外提供服务，违反了可用性的原则。
如果系统保证可用性，即使在网络分区的情况下，系统仍然需要对外提供服务。这可能会导致在不同分区上的数据副本之间出现不一致的状态，因为某些更新可能还没有被所有分区看到。
因此，在分布式系统中，当网络分区发生时，一致性和可用性不能同时成立。系统设计者需要根据具体的应用场景和需求权衡这两个属性。例如，一个银行系统可能更偏好一致性，以确保所有的账户余额随时准确无误；而一个社交网络可能更偏好可用性，允许用户在网络分区时仍能发布和查看消息，即使一些更新可能会延迟同步。


比如银行余额很要求一致性。
社交媒体需要可用性。
新的leader节点。
版本更老的leader退居二线。
曾经的 回滚。 leader变成follower。raft算法全貌。
所有节点都是受信节点。
脑裂和lease。


17 不同集群数据不一样。
不同的领导 大导 脑裂的问题。
全局过半的解决方案。
5台服务器的过半 大于等于3的选票 当选leader。
zookeeper解决脑裂 的方案。
集群的机器通信。自己投自己。
三台机器。


18 springboot service and controller
在软件架构中，特别是在遵循分层架构的应用程序中，将Controller和Service分开设计是为了关注点分离（Separation of Concerns, SoC）和单一职责原则（Single Responsibility Principle, SRP）。这样做有几个好处：

分层清晰：每层负责不同的任务。Controller层主要负责处理HTTP请求，验证输入，返回响应等。而Service层负责业务逻辑，它执行具体的操作，如数据处理和计算。

重用性：Service层可以被应用中的多个Controller重用。这意味着相同的业务逻辑不需要在不同的Controller中重复编写。

测试容易：分层架构允许独立测试每一层。例如，可以单独对Service层编写单元测试，而不需要关心HTTP请求的处理。

灵活性和可维护性：如果需要更改业务逻辑，只需要更改Service层的代码。同样，如果更改请求处理方式或引入新的请求类型，通常只影响Controller层。

减少代码耦合：控制器和服务之间通过定义清晰的接口进行通信，这有助于减少代码间的耦合度。

易于管理事务：业务逻辑层（Service层）是处理应用程序事务的理想位置，可以在这一层处理诸如数据库事务之类的操作。

在Spring Framework中，这种模式特别普遍，因为它符合Spring的设计哲学，Spring推荐的是一个轻量级的Controller层和一个充满业务逻辑的Service

比如补货员和顾客都要看是否商品库存足够 走要用这个service。而且下订单也需要用这个service。


19 high cohesion 
高内聚（High Cohesion）是软件开发中的一个设计原则，它推荐在一个模块或者一个类中应该只包含那些彼此紧密相关的功能。内聚是度量一个模块内部各个元素之间功能相关性强度的指标。高内聚通常意味着：

单一职责：每个模块或类都应该只有一个改变的理由，即只负责一件事情。
易于理解：因为模块只做一类事情，所以更加直观易懂。
易于维护：相关的功能聚集在一起，当改动一个功能时，不太可能影响到其他不相关的功能。
增强模块的可复用性：因为模块聚焦于一件事，它可以在不同的上下文中重用，而不需要包含不必要的功能。
例如，如果你有一个OrderService，它应该包含所有和订单处理相关的行为，如创建订单、计算订单总价、验证订单状态等。这样，OrderService就是高内聚的，因为它包含的所有功能都直接与订单处理相关。相对的，如果OrderService还包含了用户认证或者处理支付的逻辑，那它就是低内聚的，因为这些功能应该被分配到其他专门的服务中，例如AuthService或PaymentService。

在实践中，高内聚通常与另一个原则——低耦合（Low Coupling）——一起使用。低耦合意味着各个模块之间的依赖关系最小化，每个模块相对独立。高内聚与低耦合共同构成了可维护和可扩展软件设计的基石。


            





            健身： 3.14 容量 胸部7000kg 背部和二头2500kg 蛋白奶昔一瓶

几个建议行动：
1 力扣多刷medium和easy 主要积累巧妙解法
2 sql刷掉
3 练习java和C#写api 这个得多做项目了
4 做一份公司调查 看看每个公司用什么技术栈和项目
</p>
<p style="white-space: pre-line;">

如果把求职季度 这么做比喻 
2月初 摸底考试
3月 月考
4月 期中考 
5月 月考 5月中 期末考

我现在3月 刚面试了here technologies和特斯拉 无论月考成绩如何 我来不及为月考多想 接下来即将迎来挑战的是期中考试！我要奋战百天 期末考试倒计时百天 

我不想苟且在现在的小公司 我要去大公司 我一定要去能让我毕业后return的大公司 每一天我都会活得无比认真

3月
学习计划 1在力扣已经做的400多题里选出100来道精华的medium 无意义的hard题不纠结。把这100题刷烂。
2 做一个移动端项目 做一个nft项目/再做一个infra项目
3 把bq面试的一套视频课程看完。
4 同步投递国内岗位 投至少100份吧 美国上个月投了300份 这个月再投300份
5 sql习题做30道
6 熟练反复写50个api (java C#)
        </p>
        
        <p style="white-space: pre-line;">
          # MapReduce
            使用代码统计 20GB文件 
            可能要统计13分钟 gb级别很久 。pb tb 那就更恐怖了。
            gfs mapReduce bigTable（03-06年）
            mapReduce 大任务 拆分到小任务 divide and conquer.
            
            让家长爸妈弟弟帮忙写作业。作业撕碎给三个人 map是作业撕碎。 reduce就是作业组装。
            map shuffle分区排序。合并排序。reduce处理并且出来结果。
            生成多个map任务
            根据数据量大小 生成map任务 kv键值对。根据key计算所属分区 去到哪一个reduce。
            
            
            面试经验多了会形成综合性的结论。有些新奇的 综合性大的认知会在脑子里形成。
            比如结合tesla和here的面试，了解到需要“针对流”投简历。
            
        </p>

            <div class="section" id="section3">简历修改和公司调查</div>
        <p style="white-space: pre-line;">
            我不懂甚至不怎么听说的技术栈：RDBMS（貌似是database management system 但是不知道r是什么
            Kubernetes不懂（DE方向）遇到三次 两次是sde方向
            Robotics不太会
            Go不太会
            Helm不太会 
            Cypress不太会
            Agile 遇到两次（tesla和caci等）
            elastic（2次）
            low-level OS internals in Windows
            windows OS kernel
            system design, architecture
            测试：jest，nunit，playwright，cypress，
            部署：docker，kubernetes，jenkins
            开发方式理念：agile

            nvidia: hardware architecture.
            performance analysis
            embedded accelerators- automotive or robotics
            computer graphics: accelerated rendering apis: opengl, vulkan, directX
            autonomous driving, infotainment
            C++
            real time rendering algo
            ray tracing,
            gpu graphics pipeline
            gpu architecture
            compute programming apis
            multi-threaded programming techniques
            cuda parallel programming
            gpu development, chip design
            GPU apis, unix/ shell scripting
            ElasticSearch
            spark, elk, cassandra, kafka, angular
            high performance computing
            graphics apis(做一个项目)
            reproduce一个compiler相关的论文
            Amazon: distributed systems, linear programming

            3月 spotify 4月nft around 5月 systems architecture 6月 graphics 7月 elastic search kafka 
            8月 巩固system design 分布式系统 操作系统

            返璞归真：还是把前后端学扎实 还有系统设计 刷题。剩下的学有余力再去弄。有的放矢。
            https://www.1point3acres.com/bbs/thread-795715-2-1.html
            jobscan多用一下

        </p>

        <div class="section" id="section4">简历和公司匹配度</div>

        <p style="white-space: pre-line;">
            tesla: 39%
            spotify: 38%
            
              
          </p>

        <div class="section" id="section5">八股文，ood，system design</div>
        <p style="white-space: pre-line;">https://juejin.cn/post/7139706559092752414
            如果多做几个项目 对于写api，对于http get post delete put以及几个状态码就应该非常熟悉。
            对于database的sql也应该做到非常熟悉才对。

            https://www.youtube.com/watch?v=CsWFuFdlBVU
            学习ood
1 system design(design twitter)
            Suppose you work as an engineer at a well-known company providing social services. Your task is to improve real-time event processing to get frequent results. Which tool below will help you the most in this scenario?

           Apache Kafka is a framework for distributed real-time event processing and storage. 
           2.Assume that an account of a public figure with millions of followers posts a Tweet on Twitter. Your system will need to handle millions of interactions with this Tweet by the account’s millions of followers. Which solution below is the best way to handle this traffic, assuming that the system knows the audience details of the Tweet?
           increase or dedicate some servers to particular locations where a large portion of the audience belongs. 

           design twitter: storage, bandwidth, computational resources
           api design
           3 怎么design一个twitter
           第一 我们要去思考一些functional requirements/ non-functional requirements
           post tweets: post one or more
           delete, like, reply, search, follow, view User
           non-functional: low latency. scalability of computational resources
           4 什么是CDN
           content delivery network
           5 什么是load balancer
           performance.
           adding servers. scalability
           availability
           6 REST API复习
           的，REST API通常非常适合Web应用程序（Web apps）开发，原因如下：

简单性：REST利用了HTTP协议的现有特性，如HTTP方法（GET、POST、PUT、DELETE等）来对资源进行操作。这使得REST API相对简单易懂，并且易于实现。

无状态性：REST是无状态的，这意味着每个请求都应包含执行请求所需的所有信息，而不依赖于之前的请求。这种特性使得REST服务更容易扩展，并且更适合Web环境，其中客户端与服务器之间的交互可能非常频繁且独立。

可缓存性：RESTful服务的响应可以被明确地标记为可缓存或不可缓存，这有助于提高应用程序的性能和效率，通过减少对服务器的直接请求。

统一接口：REST的统一接口约束使得与API的交互更加一致和标准化，这有助于开发者更快地理解和使用API，同时也便于API的维护和更新。

灵活性：由于REST基于标准的HTTP协议，它可以使用任何可以发送HTTP请求的客户端进行交云。这使得创建多平台应用程序（如Web、移动和桌面应用程序）变得更加容易，因为它们都可以通过REST API与后端服务进行交互。

可伸缩性：REST API的无状态性和可缓存性使其在处理大量并发请求时表现良好，这对于构建大规模Web应用程序是非常重要的。
7 search tweet api
searchTweet(user_id, search_term, max_result, exlude, media_field, expansions, sort_order, next_token, user_location)
8 reply to tweet
replyTweet(user_id, tweet_id, tweeted_user_id, reply_type, reply_content, reply_length)


        </p>
        <div class="section" id="section5">mock interview的bq</div>
        <p style="white-space: pre-line;">
            要说自己是fullstack程序员 突出springboot java。
突出restapi的经验。

介绍公司。组织体育比赛。event system。
create the event system。没有context。
简历可以写短一点
做的东西有点空。
code base里面看别人写的怎么样。

要有一个比较困难的东西讲故事。
在hiring manager那边只会得到相同的判断。
一般都是面试senior engineer。不认得你 给出的判断是这样的。
别的项目比较完整的功能套过来。
看看code base 看看notification system有哪些东西，逻辑了解得更加透彻一点。
增加整个功能的长度。
包括你自己做这个template 你会怎么做。
mvc framework和springboot有什么不一样。
intentional的问题。
答案并不好，spring mvc也是一个mvc的framework。
大部分情况下 也要develop mvc的
jpa的功能。
java persistence api.
还可以用hibernate。
就会question你的整个简历的真实性。也许会save time。个人没有.NET的真实性。
mvc没有答出来 就不行 花过十几个小时。
简历还需要再去 写下来 看看。
写下来之后花多长时间。
算法 4个方面：1 communication 2 code quality 3 verification 4 clarification
这四条来考察。
碰到难点了 去沟通。problem-solving。最终的结果 验证的时候有没有发现问题
做的比较好的是你的communication。还不错的。
但是中间有个地方，有些面试官 你写错了 不会管的。
brute force太容易想了。但凡一线公司不会让你用这个算法过。
o n square。
用一些sorting algorithm是可以接受的。 free giveaway。 如果同意的话。
brute force is a give away.
sorting algorithm.
你的项目很水是会被发现的。
第二个hashmap 看看哪个被看过了。
算法不够灵活。sorting algorithm。
128题
nlogn可以。
最后的communication要好好弄。

提高的就是


        </p>
  
              
    </div>
</body>
</html>
